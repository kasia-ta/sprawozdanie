<!DOCTYPE html>

<html lang="pl" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>1. Partycjonowanie danych w PostgreSQL – analiza, typy, zastosowania i dobre praktyki &#8212; BazyDanych 1.0 - dokumentacja</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=331e28ce"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=2827c288"></script>
    <link rel="index" title="Indeks" href="genindex.html" />
    <link rel="search" title="Szukaj" href="search.html" />
    <link rel="next" title="2. Wydajność, skalowanie i replikacja" href="Wydajnosc-Skalowanie-i-Replikacja/index.html" />
    <link rel="prev" title="Sprawozdanie z Projektu Bazy Danych" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="partycjonowanie-danych-w-postgresql-analiza-typy-zastosowania-i-dobre-praktyki">
<h1><span class="section-number">1. </span>Partycjonowanie danych w PostgreSQL – analiza, typy, zastosowania i dobre praktyki<a class="headerlink" href="#partycjonowanie-danych-w-postgresql-analiza-typy-zastosowania-i-dobre-praktyki" title="Link to this heading">¶</a></h1>
<dl class="field-list simple">
<dt class="field-odd">Autor<span class="colon">:</span></dt>
<dd class="field-odd"><p>Bartosz Potoczny</p>
</dd>
<dt class="field-even">Data<span class="colon">:</span></dt>
<dd class="field-even"><p>2025-06-12</p>
</dd>
</dl>
<section id="streszczenie">
<h2><span class="section-number">1.1. </span>Streszczenie<a class="headerlink" href="#streszczenie" title="Link to this heading">¶</a></h2>
<p>Celem niniejszego sprawozdania jest kompleksowa analiza zagadnienia partycjonowania danych w systemie zarządzania relacyjną bazą danych PostgreSQL. Praca omawia teoretyczne podstawy partycjonowania, szczegółowo wyjaśnia wszystkie dostępne mechanizmy oraz przedstawia metody realizacji partycjonowania w praktyce. Zaprezentowano również typowe scenariusze użycia, narzędzia monitorowania oraz najlepsze praktyki projektowe. Całość przeanalizowano pod kątem wydajności, utrzymania i bezpieczeństwa danych.</p>
</section>
<section id="wprowadzenie">
<h2><span class="section-number">1.2. </span>1. Wprowadzenie<a class="headerlink" href="#wprowadzenie" title="Link to this heading">¶</a></h2>
<p>Współczesne systemy informatyczne generują i przetwarzają coraz większe ilości danych, co wymusza stosowanie zaawansowanych mechanizmów optymalizacji przechowywania i dostępu do informacji. Partycjonowanie danych jest jedną z kluczowych technik pozwalających na poprawę wydajności, skalowalności i zarządzalności baz danych. PostgreSQL, jako zaawansowany system zarządzania relacyjną bazą danych (RDBMS), oferuje rozbudowane wsparcie dla partycjonowania, umożliwiając dostosowanie architektury bazy do indywidualnych potrzeb.</p>
</section>
<section id="definicja-i-cel-partycjonowania">
<h2><span class="section-number">1.3. </span>2. Definicja i cel partycjonowania<a class="headerlink" href="#definicja-i-cel-partycjonowania" title="Link to this heading">¶</a></h2>
<p>Partycjonowanie polega na logicznym podziale dużej tabeli na mniejsze, łatwiejsze w zarządzaniu fragmenty zwane partycjami. Mimo fizycznego rozdzielenia, partycje są prezentowane użytkownikowi jako jedna wspólna tabela nadrzędna (ang. partitioned table, master table). Celem partycjonowania jest:</p>
<ul class="simple">
<li><p>Zwiększenie wydajności operacji SELECT, INSERT, UPDATE, DELETE poprzez ograniczenie zakresu danych do przeszukania (partition pruning).</p></li>
<li><p>Ułatwienie zarządzania i archiwizacji danych (np. szybkie usuwanie lub przenoszenie całych partycji).</p></li>
<li><p>Lepsze rozłożenie obciążenia (możliwość przechowywania partycji na różnych dyskach/tablespaces).</p></li>
<li><p>Zmniejszenie ryzyka zablokowania całej tabeli podczas operacji konserwacyjnych (VACUUM, REINDEX itp.).</p></li>
</ul>
</section>
<section id="modele-i-typy-partycjonowania-w-postgresql">
<h2><span class="section-number">1.4. </span>3. Modele i typy partycjonowania w PostgreSQL<a class="headerlink" href="#modele-i-typy-partycjonowania-w-postgresql" title="Link to this heading">¶</a></h2>
<p>PostgreSQL obsługuje trzy podstawowe typy partycjonowania:</p>
<p>### 3.1 Partycjonowanie zakresowe (RANGE)</p>
<p>Dane są przypisywane do partycji na podstawie wartości mieszczącej się w określonym zakresie (np. daty, numery, id). Każda partycja odpowiada innemu przedziałowi.</p>
<p><strong>Przykład:</strong></p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">events</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">event_id</span><span class="w"> </span><span class="nb">serial</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">event_date</span><span class="w"> </span><span class="nb">date</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">description</span><span class="w"> </span><span class="nb">text</span>
<span class="p">)</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">RANGE</span><span class="w"> </span><span class="p">(</span><span class="n">event_date</span><span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">events_2023</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">events</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;2023-01-01&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;2024-01-01&#39;</span><span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">events_2024</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">events</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;2024-01-01&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;2025-01-01&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Zastosowania:</strong> logi systemowe, zamówienia, dane czasowe.</p>
<p>### 3.2 Partycjonowanie listowe (LIST)</p>
<p>Dane są przypisywane do partycji na podstawie konkretnej wartości z listy (np. kraj, status, kategoria).</p>
<p><strong>Przykład:</strong></p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">sales</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">sale_id</span><span class="w"> </span><span class="nb">serial</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">country</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="nb">numeric</span>
<span class="p">)</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">LIST</span><span class="w"> </span><span class="p">(</span><span class="n">country</span><span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">sales_pl</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">sales</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;Poland&#39;</span><span class="p">);</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">sales_de</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">sales</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;Germany&#39;</span><span class="p">);</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">sales_other</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">sales</span><span class="w"> </span><span class="k">DEFAULT</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>Zastosowania:</strong> dane geograficzne, statusowe, podział według typu klienta.</p>
<p>### 3.3 Partycjonowanie haszowe (HASH)</p>
<p>Dane są rozdzielane pomiędzy partycje na podstawie funkcji haszującej zastosowanej do wybranej kolumny. Pozwala to równomiernie rozłożyć dane, gdy nie ma logicznego podziału zakresowego ani listowego.</p>
<p><strong>Przykład:</strong></p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">logs</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">log_id</span><span class="w"> </span><span class="nb">serial</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">user_id</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span>
<span class="w">    </span><span class="n">log_time</span><span class="w"> </span><span class="k">timestamp</span>
<span class="p">)</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">HASH</span><span class="w"> </span><span class="p">(</span><span class="n">user_id</span><span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">logs_p0</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">logs</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">WITH</span><span class="w"> </span><span class="p">(</span><span class="n">MODULUS</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">REMAINDER</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">logs_p1</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">logs</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">WITH</span><span class="w"> </span><span class="p">(</span><span class="n">MODULUS</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">REMAINDER</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">logs_p2</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">logs</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">WITH</span><span class="w"> </span><span class="p">(</span><span class="n">MODULUS</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">REMAINDER</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">logs_p3</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">logs</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">WITH</span><span class="w"> </span><span class="p">(</span><span class="n">MODULUS</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">REMAINDER</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Zastosowania:</strong> przypadki wymagające równomiernego rozłożenia danych, np. duże systemy telemetryczne.</p>
<p>### 3.4 Partycjonowanie wielopoziomowe (Composite/Hierarchical Partitioning)</p>
<p>PostgreSQL umożliwia tworzenie partycji podrzędnych, czyli partycjonowanie już partycjonowanych tabel (tzw. subpartitioning).</p>
<p><strong>Przykład:</strong></p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">measurements</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">serial</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">region</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span>
<span class="w">    </span><span class="n">measurement_date</span><span class="w"> </span><span class="nb">date</span><span class="p">,</span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="nb">numeric</span>
<span class="p">)</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">LIST</span><span class="w"> </span><span class="p">(</span><span class="n">region</span><span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">measurements_europe</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">measurements</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;Europe&#39;</span><span class="p">)</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">RANGE</span><span class="w"> </span><span class="p">(</span><span class="n">measurement_date</span><span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">measurements_europe_2024</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">measurements_europe</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;2024-01-01&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;2025-01-01&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Zastosowania:</strong> bardzo duże tabele, złożona struktura danych (np. po regionie i dacie).</p>
</section>
<section id="implementacja-partycjonowania-w-praktyce">
<h2><span class="section-number">1.5. </span>4. Implementacja partycjonowania w praktyce<a class="headerlink" href="#implementacja-partycjonowania-w-praktyce" title="Link to this heading">¶</a></h2>
<p>### 4.1 Tworzenie i zarządzanie partycjami</p>
<ul class="simple">
<li><p><strong>Tworzenie partycji:</strong> Partycje tworzone są jako osobne tabele, ale zarządzane przez tabelę nadrzędną.</p></li>
<li><p><strong>Dodawanie partycji:</strong> Możliwe w dowolnym momencie przy użyciu CREATE TABLE … PARTITION OF.</p></li>
<li><p><strong>Usuwanie partycji:</strong> ALTER TABLE … DETACH PARTITION + DROP TABLE (po odłączeniu partycji).</p></li>
<li><p><strong>Domyślna partycja:</strong> Można zdefiniować partycję przechowującą dane niepasujące do żadnej innej (DEFAULT).</p></li>
</ul>
<p>### 4.2 Wstawianie i odczyt danych</p>
<ul class="simple">
<li><p>Dane są automatycznie kierowane do właściwej partycji na podstawie klucza partycjonowania.</p></li>
<li><p>W przypadku braku pasującej partycji (i braku DEFAULT) – błąd constraint violation.</p></li>
<li><p>Zapytania ograniczone do klucza partycjonowania korzystają z partition pruning – przeszukują tylko wybrane partycje.</p></li>
</ul>
<p>### 4.3 Indeksowanie partycji</p>
<ul class="simple">
<li><p>Możliwe jest tworzenie indeksów na każdej partycji osobno lub dziedziczenie indeksów z tabeli nadrzędnej (od PostgreSQL 11 wzwyż).</p></li>
<li><p>Indeksy globalne (na całą tabelę partycjonowaną) nie są jeszcze dostępne (stan na 2025).</p></li>
</ul>
<p>### 4.4 Ograniczenia partycjonowania</p>
<ul class="simple">
<li><p>Klucz partycjonowania musi być częścią klucza głównego (PRIMARY KEY).</p></li>
<li><p>Niektóre operacje mogą wymagać wykonywania osobno na każdej partycji (np. VACUUM, REINDEX).</p></li>
<li><p>Wersje PostgreSQL &lt;10 obsługują partycjonowanie tylko przez dziedziczenie – obecnie uznawane za przestarzałe.</p></li>
</ul>
</section>
<section id="monitorowanie-i-administracja">
<h2><span class="section-number">1.6. </span>5. Monitorowanie i administracja<a class="headerlink" href="#monitorowanie-i-administracja" title="Link to this heading">¶</a></h2>
<p>### 5.1 Sprawdzanie rozmieszczenia danych</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">tableoid</span><span class="p">::</span><span class="n">regclass</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">partition</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">measurements</span><span class="p">;</span>
</pre></div>
</div>
<p>### 5.2 Lista partycji</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">inhrelid</span><span class="p">::</span><span class="n">regclass</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">partition</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">pg_inherits</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">inhparent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;measurements&#39;</span><span class="p">::</span><span class="n">regclass</span><span class="p">;</span>
</pre></div>
</div>
<p>### 5.3 Rozmiar partycji</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">relname</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="ss">&quot;Partition&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pg_size_pretty</span><span class="p">(</span><span class="n">pg_total_relation_size</span><span class="p">(</span><span class="n">relid</span><span class="p">))</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="ss">&quot;Size&quot;</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">pg_catalog</span><span class="p">.</span><span class="n">pg_statio_user_tables</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">relname</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;measurements%&#39;</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">pg_total_relation_size</span><span class="p">(</span><span class="n">relid</span><span class="p">)</span><span class="w"> </span><span class="k">DESC</span><span class="p">;</span>
</pre></div>
</div>
<p>### 5.4 Analiza planu zapytania (partition pruning)</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">ANALYZE</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">measurements</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">region</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Europe&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">measurement_date</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="s1">&#39;2024-01-01&#39;</span><span class="p">;</span>

<span class="c1">-- W planie widać użycie tylko właściwych partycji.</span>
</pre></div>
</div>
</section>
<section id="typowe-scenariusze-zastosowan">
<h2><span class="section-number">1.7. </span>6. Typowe scenariusze zastosowań<a class="headerlink" href="#typowe-scenariusze-zastosowan" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>Przetwarzanie danych czasowych:</strong> partycjonowanie zakresowe po dacie (logi, zamówienia, pomiary).</p></li>
<li><p><strong>Dane geograficzne lub kategoryczne:</strong> partycjonowanie listowe (kraj, region, kategoria produktu).</p></li>
<li><p><strong>Systemy telemetryczne i IoT:</strong> partycjonowanie haszowe lub wielopoziomowe (np. urządzenie + czas).</p></li>
<li><p><strong>Duże systemy ERP/CRM:</strong> partycjonowanie po kliencie, regionie, a następnie po dacie.</p></li>
</ul>
</section>
<section id="dobre-praktyki-projektowania-partycji">
<h2><span class="section-number">1.8. </span>7. Dobre praktyki projektowania partycji<a class="headerlink" href="#dobre-praktyki-projektowania-partycji" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p><strong>Dobór klucza partycjonowania:</strong> Powinien odpowiadać najczęściej używanym warunkom w zapytaniach WHERE.</p></li>
<li><p><strong>Optymalna liczba partycji:</strong> Zbyt mała liczba partycji nie daje efektu, zbyt duża zwiększa narzut administracyjny.</p></li>
<li><p><strong>Automatyzacja tworzenia partycji:</strong> Skrypty lub narzędzia generujące nowe partycje np. na kolejne miesiące/lata.</p></li>
<li><p><strong>Monitorowanie wydajności:</strong> Regularne sprawdzanie rozmiarów partycji, statystyk oraz planów wykonania zapytań.</p></li>
<li><p><strong>Bezpieczeństwo danych:</strong> Możliwość szybkiego backupu lub usunięcia starych partycji.</p></li>
</ul>
</section>
<section id="ograniczenia-i-potencjalne-problemy">
<h2><span class="section-number">1.9. </span>8. Ograniczenia i potencjalne problemy<a class="headerlink" href="#ograniczenia-i-potencjalne-problemy" title="Link to this heading">¶</a></h2>
<ul class="simple">
<li><p>Brak natywnych indeksów globalnych (stan na 2025) utrudnia niektóre zapytania przekrojowe.</p></li>
<li><p>Operacje DDL na tabeli nadrzędnej mogą być kosztowne przy dużej liczbie partycji.</p></li>
<li><p>Niektóre narzędzia zewnętrzne mogą nie obsługiwać partycji w pełni transparentnie.</p></li>
<li><p>Przenoszenie danych między partycjami wymaga operacji INSERT + DELETE lub narzędzi specjalistycznych.</p></li>
</ul>
</section>
<section id="podsumowanie-i-wnioski">
<h2><span class="section-number">1.10. </span>9. Podsumowanie i wnioski<a class="headerlink" href="#podsumowanie-i-wnioski" title="Link to this heading">¶</a></h2>
<p>Partycjonowanie danych w PostgreSQL jest zaawansowanym i elastycznym narzędziem, pozwalającym na istotną poprawę wydajności oraz ułatwiającym zarządzanie dużymi zbiorami danych. Właściwy dobór typu partycjonowania, klucza oraz liczby i organizacji partycji wymaga analizy charakterystyki danych i typowych zapytań. Zaleca się regularne monitorowanie i dostosowywanie architektury partycjonowania, zwłaszcza w przypadku dynamicznie rosnących zbiorów danych.</p>
</section>
<section id="krotkie-porownanie-partycjonowania-w-postgresql-i-innych-systemach-bazodanowych">
<h2><span class="section-number">1.11. </span>10. Krótkie porównanie partycjonowania w PostgreSQL i innych systemach bazodanowych<a class="headerlink" href="#krotkie-porownanie-partycjonowania-w-postgresql-i-innych-systemach-bazodanowych" title="Link to this heading">¶</a></h2>
<p>Partycjonowanie danych jest wspierane przez większość nowoczesnych systemów baz danych, jednak szczegóły implementacji i dostępne możliwości mogą się różnić:</p>
<ul class="simple">
<li><p><strong>PostgreSQL:</strong>
Umożliwia partycjonowanie zakresowe, listowe, haszowe oraz wielopoziomowe (od wersji 10). Partycje są w pełni zintegrowane z silnikiem (od wersji 10), a operacje na partycjonowanych tabelach są transparentne dla użytkownika. Nie obsługuje jeszcze natywnych indeksów globalnych (stan na 2025).</p></li>
<li><p><strong>Oracle Database:</strong>
Bardzo rozbudowane opcje partycjonowania (RANGE, LIST, HASH, COMPOSITE), obsługuje indeksy lokalne i globalne, automatyczne zarządzanie partycjami, także partycjonowanie na poziomie fizycznym (np. partycjonowanie indeksów, tabel LOB). Mechanizmy zaawansowane, ale często dostępne tylko w płatnych edycjach.</p></li>
<li><p><strong>MySQL (InnoDB):</strong>
Wspiera partycjonowanie RANGE, LIST, HASH, KEY. Możliwości są jednak bardziej ograniczone niż w PostgreSQL czy Oracle. Nie wszystkie operacje i typy indeksów są wspierane na partycjonowanych tabelach.</p></li>
<li><p><strong>Microsoft SQL Server:</strong>
Umożliwia partycjonowanie tabel i indeksów przy użyciu tzw. partition schemes i partition functions. Pozwala na łatwe przenoszenie partycji oraz obsługuje indeksy globalne, co ułatwia optymalizację zapytań przekrojowych.</p></li>
</ul>
<p><strong>Podsumowanie:</strong>
PostgreSQL oferuje bardzo elastyczne i wydajne partycjonowanie, jednak niektóre zaawansowane funkcje (np. partycjonowanie indeksów globalnych) są jeszcze w fazie rozwoju, podczas gdy w Oracle czy SQL Server są już dojrzałymi rozwiązaniami.</p>
</section>
<section id="przyklad-migracji-niepartyconowanej-tabeli-na-partycjonowana">
<h2><span class="section-number">1.12. </span>11. Przykład migracji niepartyconowanej tabeli na partycjonowaną<a class="headerlink" href="#przyklad-migracji-niepartyconowanej-tabeli-na-partycjonowana" title="Link to this heading">¶</a></h2>
<p>Migracja istniejącej tabeli na partycjonowaną w PostgreSQL wymaga kilku kroków. Oto przykładowy proces dla tabeli <code class="docutils literal notranslate"><span class="pre">orders</span></code>:</p>
<p><strong>Załóżmy, że mamy tabelę:</strong></p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">serial</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">order_date</span><span class="w"> </span><span class="nb">date</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">customer_id</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span>
<span class="w">    </span><span class="n">amount</span><span class="w"> </span><span class="nb">numeric</span>
<span class="p">);</span>
</pre></div>
</div>
<p><strong>Chcemy ją partycjonować po kolumnie ``order_date`` (zakresy roczne):</strong></p>
<ol class="arabic">
<li><p>Zmień nazwę oryginalnej tabeli:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="k">RENAME</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="n">orders_old</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>Utwórz nową tabelę partycjonowaną:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">serial</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">order_date</span><span class="w"> </span><span class="nb">date</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">customer_id</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span>
<span class="w">    </span><span class="n">amount</span><span class="w"> </span><span class="nb">numeric</span>
<span class="p">)</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">RANGE</span><span class="w"> </span><span class="p">(</span><span class="n">order_date</span><span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders_2023</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">orders</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;2023-01-01&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;2024-01-01&#39;</span><span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders_2024</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">orders</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;2024-01-01&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">TO</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;2025-01-01&#39;</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p>Skopiuj dane do partycji:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">order_date</span><span class="p">,</span><span class="w"> </span><span class="n">customer_id</span><span class="p">,</span><span class="w"> </span><span class="n">amount</span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">order_date</span><span class="p">,</span><span class="w"> </span><span class="n">customer_id</span><span class="p">,</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">orders_old</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>Sprawdź, czy dane zostały poprawnie rozdzielone:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">tableoid</span><span class="p">::</span><span class="n">regclass</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">tableoid</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>Usuń starą tabelę po upewnieniu się, że wszystko działa:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">DROP</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders_old</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ol>
<p>Można też użyć narzędzi automatyzujących migracje (np. pg_partman), jeśli tabel jest bardzo dużo lub są bardzo duże.</p>
</section>
<section id="bibliografia">
<h2><span class="section-number">1.13. </span>12. Bibliografia<a class="headerlink" href="#bibliografia" title="Link to this heading">¶</a></h2>
<ol class="arabic simple">
<li><p>Dokumentacja PostgreSQL: <a class="reference external" href="https://www.postgresql.org/docs/current/ddl-partitioning.html">https://www.postgresql.org/docs/current/ddl-partitioning.html</a></p></li>
<li><p>„PostgreSQL. Zaawansowane techniki programistyczne”, Grzegorz Wójtowicz, Helion 2021</p></li>
<li><p><a class="reference external" href="https://wiki.postgresql.org/wiki/Partitioning">https://wiki.postgresql.org/wiki/Partitioning</a></p></li>
<li><p>Oficjalny blog PostgreSQL: <a class="reference external" href="https://www.postgresql.org/about/news/">https://www.postgresql.org/about/news/</a></p></li>
</ol>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">BazyDanych</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Szukaj" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Nawigacja</h3>
<p class="caption" role="heading"><span class="caption-text">Spis Treści</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Partycjonowanie danych w PostgreSQL – analiza, typy, zastosowania i dobre praktyki</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#streszczenie">1.1. Streszczenie</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wprowadzenie">1.2. 1. Wprowadzenie</a></li>
<li class="toctree-l2"><a class="reference internal" href="#definicja-i-cel-partycjonowania">1.3. 2. Definicja i cel partycjonowania</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modele-i-typy-partycjonowania-w-postgresql">1.4. 3. Modele i typy partycjonowania w PostgreSQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implementacja-partycjonowania-w-praktyce">1.5. 4. Implementacja partycjonowania w praktyce</a></li>
<li class="toctree-l2"><a class="reference internal" href="#monitorowanie-i-administracja">1.6. 5. Monitorowanie i administracja</a></li>
<li class="toctree-l2"><a class="reference internal" href="#typowe-scenariusze-zastosowan">1.7. 6. Typowe scenariusze zastosowań</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dobre-praktyki-projektowania-partycji">1.8. 7. Dobre praktyki projektowania partycji</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ograniczenia-i-potencjalne-problemy">1.9. 8. Ograniczenia i potencjalne problemy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#podsumowanie-i-wnioski">1.10. 9. Podsumowanie i wnioski</a></li>
<li class="toctree-l2"><a class="reference internal" href="#krotkie-porownanie-partycjonowania-w-postgresql-i-innych-systemach-bazodanowych">1.11. 10. Krótkie porównanie partycjonowania w PostgreSQL i innych systemach bazodanowych</a></li>
<li class="toctree-l2"><a class="reference internal" href="#przyklad-migracji-niepartyconowanej-tabeli-na-partycjonowana">1.12. 11. Przykład migracji niepartyconowanej tabeli na partycjonowaną</a></li>
<li class="toctree-l2"><a class="reference internal" href="#bibliografia">1.13. 12. Bibliografia</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Wydajnosc-Skalowanie-i-Replikacja/index.html">2. Wydajność, skalowanie i replikacja</a></li>
<li class="toctree-l1"><a class="reference internal" href="Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych.html">3. Sprzęt dla baz danych</a></li>
<li class="toctree-l1"><a class="reference internal" href="Konfiguracja_baz_danych/Konfiguracja_baz_danych.html">4. Sprawozdanie: Konfiguracja i Zarządzanie Bazą Danych</a></li>
<li class="toctree-l1"><a class="reference internal" href="Bezpieczenstwo/index.html">5. Bezpieczeństwo</a></li>
<li class="toctree-l1"><a class="reference internal" href="Kontrola_i_konserwacja/kontrola_i_konserwacja.html">6. Kontrola i konserwacja baz danych</a></li>
<li class="toctree-l1"><a class="reference internal" href="Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych.html">7. Kopie zapasowe i odzyskiwanie danych w PostgreSQL</a></li>
<li class="toctree-l1"><a class="reference internal" href="rozdzial_4.html">8. Analiza i Implementacja Bazy Danych</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="poprzedni rozdział">Sprawozdanie z Projektu Bazy Danych</a></li>
      <li>Next: <a href="Wydajnosc-Skalowanie-i-Replikacja/index.html" title="następny rozdział"><span class="section-number">2. </span>Wydajność, skalowanie i replikacja</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Bartosz Potoczny.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/rozdzial_1.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>