%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,polish]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{polish}





\usepackage[Lenny]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}
\usepackage{tabularx}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionspolish{\renewcommand{\contentsname}{Spis Treści}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


\usepackage{fontspec}
\usepackage{polyglossia}
\setdefaultlanguage{polish}
\setotherlanguage{english}


\title{BazyDanych}
\date{05 lip 2025}
\release{1.0}
\author{Bartosz Potoczny}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Wydanie}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
\sphinxstylestrong{Autorzy:} Bartkosz Potoczny
\sphinxstylestrong{Data:} 05 lip 2025

\sphinxstepscope


\chapter{Partycjonowanie danych w PostgreSQL – analiza, typy, zastosowania i dobre praktyki}
\label{\detokenize{rozdzial_1:partycjonowanie-danych-w-postgresql-analiza-typy-zastosowania-i-dobre-praktyki}}\label{\detokenize{rozdzial_1::doc}}\begin{quote}\begin{description}
\sphinxlineitem{Autor}
\sphinxAtStartPar
Bartosz Potoczny

\sphinxlineitem{Data}
\sphinxAtStartPar
2025\sphinxhyphen{}06\sphinxhyphen{}12

\end{description}\end{quote}


\section{Streszczenie}
\label{\detokenize{rozdzial_1:streszczenie}}
\sphinxAtStartPar
Celem niniejszego sprawozdania jest kompleksowa analiza zagadnienia partycjonowania danych w systemie zarządzania relacyjną bazą danych PostgreSQL. Praca omawia teoretyczne podstawy partycjonowania, szczegółowo wyjaśnia wszystkie dostępne mechanizmy oraz przedstawia metody realizacji partycjonowania w praktyce. Zaprezentowano również typowe scenariusze użycia, narzędzia monitorowania oraz najlepsze praktyki projektowe. Całość przeanalizowano pod kątem wydajności, utrzymania i bezpieczeństwa danych.


\section{1. Wprowadzenie}
\label{\detokenize{rozdzial_1:wprowadzenie}}
\sphinxAtStartPar
Współczesne systemy informatyczne generują i przetwarzają coraz większe ilości danych, co wymusza stosowanie zaawansowanych mechanizmów optymalizacji przechowywania i dostępu do informacji. Partycjonowanie danych jest jedną z kluczowych technik pozwalających na poprawę wydajności, skalowalności i zarządzalności baz danych. PostgreSQL, jako zaawansowany system zarządzania relacyjną bazą danych (RDBMS), oferuje rozbudowane wsparcie dla partycjonowania, umożliwiając dostosowanie architektury bazy do indywidualnych potrzeb.


\section{2. Definicja i cel partycjonowania}
\label{\detokenize{rozdzial_1:definicja-i-cel-partycjonowania}}
\sphinxAtStartPar
Partycjonowanie polega na logicznym podziale dużej tabeli na mniejsze, łatwiejsze w zarządzaniu fragmenty zwane partycjami. Mimo fizycznego rozdzielenia, partycje są prezentowane użytkownikowi jako jedna wspólna tabela nadrzędna (ang. partitioned table, master table). Celem partycjonowania jest:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Zwiększenie wydajności operacji SELECT, INSERT, UPDATE, DELETE poprzez ograniczenie zakresu danych do przeszukania (partition pruning).

\item {} 
\sphinxAtStartPar
Ułatwienie zarządzania i archiwizacji danych (np. szybkie usuwanie lub przenoszenie całych partycji).

\item {} 
\sphinxAtStartPar
Lepsze rozłożenie obciążenia (możliwość przechowywania partycji na różnych dyskach/tablespaces).

\item {} 
\sphinxAtStartPar
Zmniejszenie ryzyka zablokowania całej tabeli podczas operacji konserwacyjnych (VACUUM, REINDEX itp.).

\end{itemize}


\section{3. Modele i typy partycjonowania w PostgreSQL}
\label{\detokenize{rozdzial_1:modele-i-typy-partycjonowania-w-postgresql}}
\sphinxAtStartPar
PostgreSQL obsługuje trzy podstawowe typy partycjonowania:

\sphinxAtStartPar
\#\#\# 3.1 Partycjonowanie zakresowe (RANGE)

\sphinxAtStartPar
Dane są przypisywane do partycji na podstawie wartości mieszczącej się w określonym zakresie (np. daty, numery, id). Każda partycja odpowiada innemu przedziałowi.

\sphinxAtStartPar
\sphinxstylestrong{Przykład:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{events}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{event\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{serial}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{event\PYGZus{}date}\PYG{+w}{ }\PYG{n+nb}{date}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{description}\PYG{+w}{ }\PYG{n+nb}{text}
\PYG{p}{)}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{RANGE}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{event\PYGZus{}date}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{events\PYGZus{}2023}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{events}
\PYG{+w}{    }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2023\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2024\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{events\PYGZus{}2024}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{events}
\PYG{+w}{    }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2024\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2025\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Zastosowania:} logi systemowe, zamówienia, dane czasowe.

\sphinxAtStartPar
\#\#\# 3.2 Partycjonowanie listowe (LIST)

\sphinxAtStartPar
Dane są przypisywane do partycji na podstawie konkretnej wartości z listy (np. kraj, status, kategoria).

\sphinxAtStartPar
\sphinxstylestrong{Przykład:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{sales}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{sale\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{serial}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{country}\PYG{+w}{ }\PYG{n+nb}{text}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{value}\PYG{+w}{ }\PYG{n+nb}{numeric}
\PYG{p}{)}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{LIST}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{country}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{sales\PYGZus{}pl}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{sales}\PYG{+w}{ }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{IN}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Poland\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{sales\PYGZus{}de}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{sales}\PYG{+w}{ }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{IN}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Germany\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{sales\PYGZus{}other}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{sales}\PYG{+w}{ }\PYG{k}{DEFAULT}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Zastosowania:} dane geograficzne, statusowe, podział według typu klienta.

\sphinxAtStartPar
\#\#\# 3.3 Partycjonowanie haszowe (HASH)

\sphinxAtStartPar
Dane są rozdzielane pomiędzy partycje na podstawie funkcji haszującej zastosowanej do wybranej kolumny. Pozwala to równomiernie rozłożyć dane, gdy nie ma logicznego podziału zakresowego ani listowego.

\sphinxAtStartPar
\sphinxstylestrong{Przykład:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{logs}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{log\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{serial}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{user\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{int}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{log\PYGZus{}time}\PYG{+w}{ }\PYG{k}{timestamp}
\PYG{p}{)}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{HASH}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{user\PYGZus{}id}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{logs\PYGZus{}p0}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{logs}\PYG{+w}{ }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{WITH}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{MODULUS}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{REMAINDER}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{logs\PYGZus{}p1}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{logs}\PYG{+w}{ }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{WITH}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{MODULUS}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{REMAINDER}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{logs\PYGZus{}p2}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{logs}\PYG{+w}{ }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{WITH}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{MODULUS}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{REMAINDER}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{logs\PYGZus{}p3}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{logs}\PYG{+w}{ }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{WITH}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{MODULUS}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{REMAINDER}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Zastosowania:} przypadki wymagające równomiernego rozłożenia danych, np. duże systemy telemetryczne.

\sphinxAtStartPar
\#\#\# 3.4 Partycjonowanie wielopoziomowe (Composite/Hierarchical Partitioning)

\sphinxAtStartPar
PostgreSQL umożliwia tworzenie partycji podrzędnych, czyli partycjonowanie już partycjonowanych tabel (tzw. subpartitioning).

\sphinxAtStartPar
\sphinxstylestrong{Przykład:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{measurements}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{id}\PYG{+w}{ }\PYG{n+nb}{serial}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{region}\PYG{+w}{ }\PYG{n+nb}{text}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{measurement\PYGZus{}date}\PYG{+w}{ }\PYG{n+nb}{date}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{value}\PYG{+w}{ }\PYG{n+nb}{numeric}
\PYG{p}{)}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{LIST}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{region}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{measurements\PYGZus{}europe}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{measurements}
\PYG{+w}{    }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{IN}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Europe\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{RANGE}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{measurement\PYGZus{}date}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{measurements\PYGZus{}europe\PYGZus{}2024}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{measurements\PYGZus{}europe}
\PYG{+w}{    }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2024\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2025\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Zastosowania:} bardzo duże tabele, złożona struktura danych (np. po regionie i dacie).


\section{4. Implementacja partycjonowania w praktyce}
\label{\detokenize{rozdzial_1:implementacja-partycjonowania-w-praktyce}}
\sphinxAtStartPar
\#\#\# 4.1 Tworzenie i zarządzanie partycjami
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Tworzenie partycji:} Partycje tworzone są jako osobne tabele, ale zarządzane przez tabelę nadrzędną.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dodawanie partycji:} Możliwe w dowolnym momencie przy użyciu CREATE TABLE … PARTITION OF.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Usuwanie partycji:} ALTER TABLE … DETACH PARTITION + DROP TABLE (po odłączeniu partycji).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Domyślna partycja:} Można zdefiniować partycję przechowującą dane niepasujące do żadnej innej (DEFAULT).

\end{itemize}

\sphinxAtStartPar
\#\#\# 4.2 Wstawianie i odczyt danych
\begin{itemize}
\item {} 
\sphinxAtStartPar
Dane są automatycznie kierowane do właściwej partycji na podstawie klucza partycjonowania.

\item {} 
\sphinxAtStartPar
W przypadku braku pasującej partycji (i braku DEFAULT) – błąd constraint violation.

\item {} 
\sphinxAtStartPar
Zapytania ograniczone do klucza partycjonowania korzystają z partition pruning – przeszukują tylko wybrane partycje.

\end{itemize}

\sphinxAtStartPar
\#\#\# 4.3 Indeksowanie partycji
\begin{itemize}
\item {} 
\sphinxAtStartPar
Możliwe jest tworzenie indeksów na każdej partycji osobno lub dziedziczenie indeksów z tabeli nadrzędnej (od PostgreSQL 11 wzwyż).

\item {} 
\sphinxAtStartPar
Indeksy globalne (na całą tabelę partycjonowaną) nie są jeszcze dostępne (stan na 2025).

\end{itemize}

\sphinxAtStartPar
\#\#\# 4.4 Ograniczenia partycjonowania
\begin{itemize}
\item {} 
\sphinxAtStartPar
Klucz partycjonowania musi być częścią klucza głównego (PRIMARY KEY).

\item {} 
\sphinxAtStartPar
Niektóre operacje mogą wymagać wykonywania osobno na każdej partycji (np. VACUUM, REINDEX).

\item {} 
\sphinxAtStartPar
Wersje PostgreSQL <10 obsługują partycjonowanie tylko przez dziedziczenie – obecnie uznawane za przestarzałe.

\end{itemize}


\section{5. Monitorowanie i administracja}
\label{\detokenize{rozdzial_1:monitorowanie-i-administracja}}
\sphinxAtStartPar
\#\#\# 5.1 Sprawdzanie rozmieszczenia danych

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{tableoid}\PYG{p}{:}\PYG{p}{:}\PYG{n}{regclass}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{n}{partition}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{measurements}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\#\#\# 5.2 Lista partycji

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{inhrelid}\PYG{p}{:}\PYG{p}{:}\PYG{n}{regclass}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{n}{partition}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}inherits}
\PYG{k}{WHERE}\PYG{+w}{ }\PYG{n}{inhparent}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}measurements\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{regclass}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\#\#\# 5.3 Rozmiar partycji

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{relname}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}Partition\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{n}{relid}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{l+s+ss}{\PYGZdq{}Size\PYGZdq{}}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}catalog}\PYG{p}{.}\PYG{n}{pg\PYGZus{}statio\PYGZus{}user\PYGZus{}tables}
\PYG{k}{WHERE}\PYG{+w}{ }\PYG{n}{relname}\PYG{+w}{ }\PYG{k}{LIKE}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}measurements\PYGZpc{}\PYGZsq{}}
\PYG{k}{ORDER}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{n}{relid}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{DESC}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\#\#\# 5.4 Analiza planu zapytania (partition pruning)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{EXPLAIN}\PYG{+w}{ }\PYG{k}{ANALYZE}
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{measurements}\PYG{+w}{ }\PYG{k}{WHERE}\PYG{+w}{ }\PYG{n}{region}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}Europe\PYGZsq{}}\PYG{+w}{ }\PYG{k}{AND}\PYG{+w}{ }\PYG{n}{measurement\PYGZus{}date}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}2024\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{;}

\PYG{c+c1}{\PYGZhy{}\PYGZhy{} W planie widać użycie tylko właściwych partycji.}
\end{sphinxVerbatim}


\section{6. Typowe scenariusze zastosowań}
\label{\detokenize{rozdzial_1:typowe-scenariusze-zastosowan}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Przetwarzanie danych czasowych:} partycjonowanie zakresowe po dacie (logi, zamówienia, pomiary).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dane geograficzne lub kategoryczne:} partycjonowanie listowe (kraj, region, kategoria produktu).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Systemy telemetryczne i IoT:} partycjonowanie haszowe lub wielopoziomowe (np. urządzenie + czas).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Duże systemy ERP/CRM:} partycjonowanie po kliencie, regionie, a następnie po dacie.

\end{itemize}


\section{7. Dobre praktyki projektowania partycji}
\label{\detokenize{rozdzial_1:dobre-praktyki-projektowania-partycji}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dobór klucza partycjonowania:} Powinien odpowiadać najczęściej używanym warunkom w zapytaniach WHERE.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Optymalna liczba partycji:} Zbyt mała liczba partycji nie daje efektu, zbyt duża zwiększa narzut administracyjny.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Automatyzacja tworzenia partycji:} Skrypty lub narzędzia generujące nowe partycje np. na kolejne miesiące/lata.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Monitorowanie wydajności:} Regularne sprawdzanie rozmiarów partycji, statystyk oraz planów wykonania zapytań.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bezpieczeństwo danych:} Możliwość szybkiego backupu lub usunięcia starych partycji.

\end{itemize}


\section{8. Ograniczenia i potencjalne problemy}
\label{\detokenize{rozdzial_1:ograniczenia-i-potencjalne-problemy}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Brak natywnych indeksów globalnych (stan na 2025) utrudnia niektóre zapytania przekrojowe.

\item {} 
\sphinxAtStartPar
Operacje DDL na tabeli nadrzędnej mogą być kosztowne przy dużej liczbie partycji.

\item {} 
\sphinxAtStartPar
Niektóre narzędzia zewnętrzne mogą nie obsługiwać partycji w pełni transparentnie.

\item {} 
\sphinxAtStartPar
Przenoszenie danych między partycjami wymaga operacji INSERT + DELETE lub narzędzi specjalistycznych.

\end{itemize}


\section{9. Podsumowanie i wnioski}
\label{\detokenize{rozdzial_1:podsumowanie-i-wnioski}}
\sphinxAtStartPar
Partycjonowanie danych w PostgreSQL jest zaawansowanym i elastycznym narzędziem, pozwalającym na istotną poprawę wydajności oraz ułatwiającym zarządzanie dużymi zbiorami danych. Właściwy dobór typu partycjonowania, klucza oraz liczby i organizacji partycji wymaga analizy charakterystyki danych i typowych zapytań. Zaleca się regularne monitorowanie i dostosowywanie architektury partycjonowania, zwłaszcza w przypadku dynamicznie rosnących zbiorów danych.


\section{10. Krótkie porównanie partycjonowania w PostgreSQL i innych systemach bazodanowych}
\label{\detokenize{rozdzial_1:krotkie-porownanie-partycjonowania-w-postgresql-i-innych-systemach-bazodanowych}}
\sphinxAtStartPar
Partycjonowanie danych jest wspierane przez większość nowoczesnych systemów baz danych, jednak szczegóły implementacji i dostępne możliwości mogą się różnić:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{PostgreSQL:}
Umożliwia partycjonowanie zakresowe, listowe, haszowe oraz wielopoziomowe (od wersji 10). Partycje są w pełni zintegrowane z silnikiem (od wersji 10), a operacje na partycjonowanych tabelach są transparentne dla użytkownika. Nie obsługuje jeszcze natywnych indeksów globalnych (stan na 2025).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Oracle Database:}
Bardzo rozbudowane opcje partycjonowania (RANGE, LIST, HASH, COMPOSITE), obsługuje indeksy lokalne i globalne, automatyczne zarządzanie partycjami, także partycjonowanie na poziomie fizycznym (np. partycjonowanie indeksów, tabel LOB). Mechanizmy zaawansowane, ale często dostępne tylko w płatnych edycjach.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{MySQL (InnoDB):}
Wspiera partycjonowanie RANGE, LIST, HASH, KEY. Możliwości są jednak bardziej ograniczone niż w PostgreSQL czy Oracle. Nie wszystkie operacje i typy indeksów są wspierane na partycjonowanych tabelach.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Microsoft SQL Server:}
Umożliwia partycjonowanie tabel i indeksów przy użyciu tzw. partition schemes i partition functions. Pozwala na łatwe przenoszenie partycji oraz obsługuje indeksy globalne, co ułatwia optymalizację zapytań przekrojowych.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Podsumowanie:}
PostgreSQL oferuje bardzo elastyczne i wydajne partycjonowanie, jednak niektóre zaawansowane funkcje (np. partycjonowanie indeksów globalnych) są jeszcze w fazie rozwoju, podczas gdy w Oracle czy SQL Server są już dojrzałymi rozwiązaniami.


\section{11. Przykład migracji niepartyconowanej tabeli na partycjonowaną}
\label{\detokenize{rozdzial_1:przyklad-migracji-niepartyconowanej-tabeli-na-partycjonowana}}
\sphinxAtStartPar
Migracja istniejącej tabeli na partycjonowaną w PostgreSQL wymaga kilku kroków. Oto przykładowy proces dla tabeli \sphinxcode{\sphinxupquote{orders}}:

\sphinxAtStartPar
\sphinxstylestrong{Załóżmy, że mamy tabelę:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{id}\PYG{+w}{ }\PYG{n+nb}{serial}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{order\PYGZus{}date}\PYG{+w}{ }\PYG{n+nb}{date}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{customer\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{int}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{amount}\PYG{+w}{ }\PYG{n+nb}{numeric}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Chcemy ją partycjonować po kolumnie ``order\_date`` (zakresy roczne):}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Zmień nazwę oryginalnej tabeli:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ALTER}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders}\PYG{+w}{ }\PYG{k}{RENAME}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{n}{orders\PYGZus{}old}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Utwórz nową tabelę partycjonowaną:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{id}\PYG{+w}{ }\PYG{n+nb}{serial}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{order\PYGZus{}date}\PYG{+w}{ }\PYG{n+nb}{date}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{customer\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{int}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{amount}\PYG{+w}{ }\PYG{n+nb}{numeric}
\PYG{p}{)}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{RANGE}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{order\PYGZus{}date}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders\PYGZus{}2023}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{orders}
\PYG{+w}{    }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2023\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2024\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders\PYGZus{}2024}\PYG{+w}{ }\PYG{n}{PARTITION}\PYG{+w}{ }\PYG{k}{OF}\PYG{+w}{ }\PYG{n}{orders}
\PYG{+w}{    }\PYG{k}{FOR}\PYG{+w}{ }\PYG{k}{VALUES}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2024\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{TO}\PYG{+w}{ }\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}2025\PYGZhy{}01\PYGZhy{}01\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Skopiuj dane do partycji:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{INSERT}\PYG{+w}{ }\PYG{k}{INTO}\PYG{+w}{ }\PYG{n}{orders}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{id}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{order\PYGZus{}date}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{customer\PYGZus{}id}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{amount}\PYG{p}{)}
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{id}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{order\PYGZus{}date}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{customer\PYGZus{}id}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{amount}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{orders\PYGZus{}old}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Sprawdź, czy dane zostały poprawnie rozdzielone:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{tableoid}\PYG{p}{:}\PYG{p}{:}\PYG{n}{regclass}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{COUNT}\PYG{p}{(}\PYG{o}{*}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{orders}\PYG{+w}{ }\PYG{k}{GROUP}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{tableoid}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Usuń starą tabelę po upewnieniu się, że wszystko działa:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{DROP}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{orders\PYGZus{}old}\PYG{p}{;}
\end{sphinxVerbatim}

\end{enumerate}

\sphinxAtStartPar
Można też użyć narzędzi automatyzujących migracje (np. pg\_partman), jeśli tabel jest bardzo dużo lub są bardzo duże.


\section{12. Bibliografia}
\label{\detokenize{rozdzial_1:bibliografia}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Dokumentacja PostgreSQL: \sphinxurl{https://www.postgresql.org/docs/current/ddl-partitioning.html}

\item {} 
\sphinxAtStartPar
„PostgreSQL. Zaawansowane techniki programistyczne”, Grzegorz Wójtowicz, Helion 2021

\item {} 
\sphinxAtStartPar
\sphinxurl{https://wiki.postgresql.org/wiki/Partitioning}

\item {} 
\sphinxAtStartPar
Oficjalny blog PostgreSQL: \sphinxurl{https://www.postgresql.org/about/news/}

\end{enumerate}

\sphinxstepscope


\chapter{Wydajność, skalowanie i replikacja}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:wydajnosc-skalowanie-i-replikacja}}\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index::doc}}\begin{quote}\begin{description}
\sphinxlineitem{Autorzy}\begin{itemize}
\item {} 
\sphinxAtStartPar
Mateusz Brokos

\item {} 
\sphinxAtStartPar
Szymon Blatkowski

\item {} 
\sphinxAtStartPar
Maciej Gołębiowski

\end{itemize}

\end{description}\end{quote}


\section{Wstęp}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:wstep}}
\sphinxAtStartPar
Celem niniejszej pracy jest omówienie kluczowych zagadnień związanych z wydajnością, skalowaniem oraz replikacją baz danych. Współczesne systemy informatyczne wymagają wysokiej dostępności i szybkiego przetwarzania danych, dlatego odpowiednie mechanizmy replikacji i optymalizacji wydajności odgrywają istotną rolę w zapewnieniu niezawodnego działania aplikacji. Praca przedstawia różne podejścia do replikacji danych, sposoby testowania wydajności sprzętu oraz techniki zarządzania zasobami i kontrolowania dostępu użytkowników. Omówiono również praktyczne rozwiązania stosowane w popularnych systemach baz danych, takich jak MySQL i PostgreSQL.


\section{Buforowanie oraz zarządzanie połączeniami}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:buforowanie-oraz-zarzadzanie-polaczeniami}}
\sphinxAtStartPar
Buforowanie i zarządzanie połączeniami to kluczowe mechanizmy zwiększające wydajność i stabilność systemu.


\subsection{Buforowanie połączeń:}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:buforowanie-polaczen}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Unieważnienie (Inwalidacja) bufora: Proces usuwania nieaktualnych danych z pamięci podręcznej, aby aplikacja zawsze korzystała ze świeżych informacji. Może być wykonywana automatycznie (np. przez wygasanie danych) lub ręcznie przez aplikację.

\item {} 
\sphinxAtStartPar
Buforowanie wyników: Polega na przechowywaniu rezultatów złożonych zapytań w pamięci podręcznej, co pozwala uniknąć ich wielokrotnego wykonywania i poprawia wydajność systemu, zwłaszcza przy operacjach na wielu tabelach.

\item {} 
\sphinxAtStartPar
Zapisywanie wyników zapytań: Wyniki często wykonywanych zapytań są przechowywane w cache, dzięki czemu aplikacja może je szybko odczytać, co zmniejsza obciążenie bazy danych i przyspiesza odpowiedź.

\end{itemize}


\subsection{Zarządzanie połączeniami:}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:zarzadzanie-polaczeniami}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Monitorowanie parametrów połączeń: Śledzenie wskaźników takich jak czas reakcji, błędy łączenia i ilość przesyłanych danych. Regularne monitorowanie pozwala szybko wykrywać i usuwać problemy, zwiększając stabilność i wydajność systemu.

\item {} 
\sphinxAtStartPar
Zarządzanie grupami połączeń: Utrzymywanie zestawu aktywnych połączeń, które mogą być wielokrotnie wykorzystywane. Ogranicza to konieczność tworzenia nowych połączeń, co poprawia wydajność i oszczędza zasoby.

\item {} 
\sphinxAtStartPar
Obsługa transakcji: Kontrola przebiegu transakcji w bazie danych w celu zapewnienia spójności i integralności danych. Wszystkie operacje w transakcji są realizowane jako jedna niepodzielna jednostka, co zapobiega konfliktom.

\end{itemize}


\section{Wydajność}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:wydajnosc}}
\sphinxAtStartPar
Wydajność bazy danych to kluczowy czynnik wpływający na skuteczne zarządzanie danymi i funkcjonowanie organizacji. W dobie cyfrowej transformacji optymalizacja działania baz stanowi istotny element strategii IT. W tym rozdziale omówiono sześć głównych wskaźników wydajności: czas odpowiedzi, przepustowość, współbieżność, wykorzystanie zasobów, problem zapytań N+1 oraz błędy w bazie danych. Regularne monitorowanie tych parametrów i odpowiednie reagowanie zapewnia stabilność systemu i wysoką efektywność pracy. Zaniedbanie ich kontroli grozi spadkiem wydajności, ryzykiem utraty danych i poważnymi awariami.


\subsection{Klastry oraz indeksy}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:klastry-oraz-indeksy}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Klaster w bazie danych to metoda organizacji, w której powiązane tabele są przechowywane na tym samym obszarze dysku. Dzięki relacjom za pomocą kluczy obcych dane znajdują się blisko siebie, co skraca czas dostępu i zwiększa wydajność wyszukiwania.

\item {} 
\sphinxAtStartPar
Indeks w bazie danych to struktura przypominająca spis treści, która pozwala szybko lokalizować dane w tabeli bez konieczności jej pełnego przeszukiwania. Tworzenie indeksów na kolumnach znacząco przyspiesza operacje wyszukiwania i dostępu.

\end{itemize}


\subsection{1. Współbieżność w bazach danych}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:wspolbieznosc-w-bazach-danych}}
\sphinxAtStartPar
Współbieżność w bazach danych oznacza zdolność systemu do jednoczesnego przetwarzania wielu operacji, co ma kluczowe znaczenie tam, gdzie wielu użytkowników korzysta z bazy w tym samym czasie. Poziom współbieżności mierzy się m.in. liczbą transakcji na sekundę (TPS) i zapytań na sekundę (QPS).
\begin{description}
\sphinxlineitem{Na wysoką współbieżność wpływają:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Poziomy izolacji transakcji, które równoważą spójność danych i możliwość równoległej pracy – wyższe poziomy izolacji zwiększają dokładność, ale mogą ograniczać współbieżność przez blokady.

\item {} 
\sphinxAtStartPar
Mechanizmy blokad, które minimalizują konflikty między transakcjami i zapewniają płynne działanie systemu.

\item {} 
\sphinxAtStartPar
Architektura systemu, zwłaszcza rozproszona, umożliwiająca rozłożenie obciążenia na wiele węzłów i poprawę skalowalności.

\end{itemize}

\sphinxlineitem{Do głównych wyzwań należą:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Hotspoty danych, czyli miejsca często jednocześnie odczytywane lub modyfikowane, tworzące wąskie gardła.

\item {} 
\sphinxAtStartPar
Zakleszczenia, gdy transakcje wzajemnie się blokują, uniemożliwiając zakończenie pracy.

\item {} 
\sphinxAtStartPar
Głód zasobów, kiedy niektóre operacje monopolizują zasoby, ograniczając dostęp innym procesom i obniżając wydajność.

\end{itemize}

\end{description}


\subsection{2. Przepustowość bazy danych}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:przepustowosc-bazy-danych}}
\sphinxAtStartPar
Przepustowość bazy danych to miara zdolności systemu do efektywnego przetwarzania określonej liczby operacji w jednostce czasu. Im wyższa, tym więcej zapytań lub transakcji baza obsłuży szybko i sprawnie.
\begin{description}
\sphinxlineitem{Na przepustowość wpływają:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Współbieżność: Skuteczne zarządzanie transakcjami i blokadami pozwala na równoczesne operacje bez konfliktów, co jest ważne przy dużym obciążeniu (np. w sklepach internetowych).

\item {} 
\sphinxAtStartPar
Bazy NoSQL: Często stosują model ewentualnej spójności, umożliwiając szybsze zapisy bez oczekiwania na pełną synchronizację replik.

\item {} 
\sphinxAtStartPar
Dystrybuowanie danych: Techniki takie jak sharding (NoSQL) czy partycjonowanie (SQL) rozkładają dane na różne serwery, zwiększając zdolność przetwarzania wielu operacji jednocześnie.

\end{itemize}

\end{description}

\sphinxAtStartPar
Podsumowując, odpowiednie zarządzanie współbieżnością, wybór architektury i rozproszenie danych to klucz do wysokiej przepustowości bazy danych.


\subsection{3. Responsywność bazy danych}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:responsywnosc-bazy-danych}}
\sphinxAtStartPar
Czasy odpowiedzi bazy danych są kluczowe w środowiskach wymagających szybkich decyzji, np. w finansach czy sytuacjach kryzysowych.
\begin{description}
\sphinxlineitem{Na czas reakcji bazy wpływają:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Architektura bazy: dobrze zaprojektowane partycjonowanie, indeksowanie oraz bazy działające w pamięci operacyjnej znacząco przyspieszają dostęp do danych.

\item {} 
\sphinxAtStartPar
Topologia oraz stan sieci: opóźnienia, przepustowość i stabilność sieci w systemach rozproszonych wpływają na szybkość przesyłu danych; optymalizacja i kompresja zmniejszają te opóźnienia.

\item {} 
\sphinxAtStartPar
Balansowanie obciążeń oraz dostęp równoczesny: pooling połączeń, replikacja i równoważenie obciążenia pomagają utrzymać krótkie czasy odpowiedzi przy dużym ruchu.

\end{itemize}

\end{description}

\sphinxAtStartPar
Szybkie odpowiedzi podnoszą efektywność, satysfakcję użytkowników i konkurencyjność systemu bazodanowego.


\subsection{4. Zapytania N+1}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:zapytania-n-1}}
\sphinxAtStartPar
Problem zapytań typu N+1 to częsta nieefektywność w aplikacjach korzystających z ORM, polegająca na wykonywaniu wielu zapytań – jednego głównego i osobnego dla każdego powiązanego rekordu. Na przykład, pobranie 10 użytkowników i osobne zapytanie o profil dla każdego daje łącznie 11 zapytań.
\begin{description}
\sphinxlineitem{Przyczyny to:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Błędna konfiguracja ORM, szczególnie „leniwe ładowanie”, powodujące nadmiar zapytań.

\item {} 
\sphinxAtStartPar
Nieoptymalne wzorce dostępu do danych, np. pobieranie danych w pętlach.

\item {} 
\sphinxAtStartPar
Niewykorzystanie złączeń SQL (JOIN), które pozwalają na pobranie danych w jednym zapytaniu.

\end{itemize}

\end{description}


\subsection{5. Błędy w bazach danych}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:bledy-w-bazach-danych}}
\sphinxAtStartPar
Błędy wpływające na wydajność bazy danych to istotny wskaźnik kondycji systemu.
\begin{description}
\sphinxlineitem{Najczęstsze typy błędów to:}\begin{itemize}
\item {} 
\sphinxAtStartPar
Błędy składni zapytań – wynikają z niepoprawnej składni SQL, powodując odrzucenie zapytania.

\item {} 
\sphinxAtStartPar
Błędy połączenia – problemy z nawiązaniem połączenia, często przez awarie sieci, błędne konfiguracje lub awarie serwera.

\item {} 
\sphinxAtStartPar
Błędy limitów zasobów – gdy system przekracza dostępne zasoby (dysk, CPU, pamięć), co może spowalniać lub zatrzymywać działanie.

\item {} 
\sphinxAtStartPar
Naruszenia ograniczeń – próby wstawienia danych łamiących zasady integralności (np. duplikaty tam, gdzie wymagana jest unikalność).

\item {} 
\sphinxAtStartPar
Błędy uprawnień i zabezpieczeń – brak odpowiednich praw dostępu skutkuje odmową operacji na danych.

\end{itemize}

\sphinxAtStartPar
Skuteczna identyfikacja i usuwanie tych błędów jest kluczowa dla stabilności i wydajności bazy danych.

\end{description}


\subsection{6. Zużycie dostępnych zasobów}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:zuzycie-dostepnych-zasobow}}
\sphinxAtStartPar
Zużycie zasobów w bazach danych to kluczowy czynnik wpływający na ich wydajność.
\begin{description}
\sphinxlineitem{Najważniejsze zasoby to:}\begin{itemize}
\item {} 
\sphinxAtStartPar
CPU: Odpowiada za przetwarzanie zapytań i zarządzanie transakcjami. Nadmierne obciążenie może wskazywać na przeciążenie lub nieoptymalne zapytania.

\item {} 
\sphinxAtStartPar
Operacje I/O na dysku: Odczyt i zapis danych. Wysoka liczba operacji może oznaczać słabe buforowanie; efektywne cache’owanie zmniejsza potrzebę częstego dostępu do dysku i eliminuje wąskie gardła.

\item {} 
\sphinxAtStartPar
Pamięć RAM: służy do przechowywania często używanych danych i buforów. Jej niedobór lub złe zarządzanie powoduje korzystanie z wolniejszej pamięci dyskowej, co obniża wydajność.

\end{itemize}

\end{description}

\sphinxAtStartPar
Dobre zarządzanie CPU, pamięcią i operacjami dyskowymi jest niezbędne dla utrzymania wysokiej wydajności i stabilności systemu bazodanowego.


\subsection{Prostota rozbudowy:}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:prostota-rozbudowy}}
\sphinxAtStartPar
Bazy danych SQL typu scale\sphinxhyphen{}out umożliwiają liniową skalowalność przez dodawanie nowych węzłów do klastra bez przestojów i zmian w aplikacji czy sprzęcie. Każdy węzeł aktywnie przetwarza transakcje, a logika bazy jest przenoszona do tych węzłów, co ogranicza transfer danych w sieci i redukuje ruch. Tylko jeden węzeł obsługuje zapisy dla danego fragmentu danych, eliminując rywalizację o zasoby, co poprawia wydajność w porównaniu do tradycyjnych baz, gdzie blokady danych spowalniają system przy wielu operacjach jednocześnie.


\subsection{Analityka czasu rzeczywistego:}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:analityka-czasu-rzeczywistego}}
\sphinxAtStartPar
Analityka czasu rzeczywistego w Big Data umożliwia natychmiastową analizę danych, dając firmom przewagę konkurencyjną. Skalowalne bazy SQL pozwalają na szybkie przetwarzanie danych operacyjnych dzięki technikom działającym w pamięci operacyjnej i wykorzystującym szybkie dyski SSD, bez potrzeby stosowania skomplikowanych rozwiązań. Przykłady Google (baza F1 SQL w Adwords) i Facebooka pokazują, że relacyjne bazy danych są efektywne zarówno w OLTP, jak i OLAP, a integracja SQL z ekosystemem Hadoop zwiększa możliwości analityczne przy jednoczesnym ograniczeniu zapotrzebowania na specjalistów.


\subsection{Dostępność w chmurze:}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:dostepnosc-w-chmurze}}
\sphinxAtStartPar
Organizacje wymagają nieprzerwanej pracy aplikacji produkcyjnych, co zapewnia ciągłość procesów biznesowych. W przypadku awarii chmury szybkie przywrócenie bazy danych bez utraty danych jest kluczowe. Skalowalne bazy SQL realizują to poprzez mechanizmy wysokiej dostępności, które opierają się na replikacji wielu kopii danych, minimalizując ryzyko ich utraty.


\subsection{Unikanie wąskich gardeł:}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:unikanie-waskich-gardel}}
\sphinxAtStartPar
W skalowalnych bazach danych SQL rozwiązano problem logu transakcyjnego, który w tradycyjnych systemach często stanowił wąskie gardło wydajności. W klasycznych rozwiązaniach wszystkie rekordy muszą być najpierw zapisane w logu transakcyjnym przed zakończeniem zapytania. Niewłaściwa konfiguracja lub awarie mogą powodować nadmierne rozrosty logu, czasem przekraczające rozmiar samej bazy, co skutkuje znacznym spowolnieniem operacji zapisu, nawet przy użyciu szybkich dysków SSD.


\section{Skalowanie}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:skalowanie}}
\sphinxAtStartPar
Bazy danych SQL nie są tak kosztowne w rozbudowie, jak się często uważa, ponieważ oferują możliwość skalowania poziomego. Ta cecha jest szczególnie cenna w analizie danych biznesowych, gdzie rośnie potrzeba przetwarzania danych klientów z wielu źródeł w czasie rzeczywistym. Obok tradycyjnych rozwiązań dostępne są również bazy NoSQL, NewSQL oraz platformy oparte na Hadoop, które odpowiadają na różne wyzwania związane z przetwarzaniem dużych ilości danych. Skalowanie poziome z optymalnym balansem pomiędzy pamięcią RAM a pamięcią flash pozwala osiągnąć wysoką wydajność. Przykłady nowoczesnych skalowalnych baz SQL, takich jak InfiniSQL, ClustrixDB czy F1, potwierdzają, że tradycyjne bazy SQL mogą efektywnie skalować się wszerz.


\section{Replikacja}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:replikacja}}
\sphinxAtStartPar
Replikacja danych to proces kopiowania informacji między różnymi serwerami baz danych, który przynosi wiele korzyści:
\sphinxhyphen{} Zwiększenie skalowalności – obciążenie systemu jest rozdzielane między wiele serwerów; zapisy i aktualizacje odbywają się na jednym serwerze, natomiast odczyty i wyszukiwania na innych, co poprawia wydajność.
\sphinxhyphen{} Poprawa bezpieczeństwa – tworzenie kopii bazy produkcyjnej pozwala chronić dane przed awariami sprzętu, choć nie zabezpiecza przed błędnymi operacjami wykonywanymi na bazie (np. DROP TABLE).
\sphinxhyphen{} Zapewnienie separacji środowisk – kopia bazy może być udostępniona zespołom programistycznym i testerskim, umożliwiając pracę na izolowanym środowisku bez ryzyka wpływu na bazę produkcyjną.
\sphinxhyphen{} Ułatwienie analizy danych – obciążające analizy i obliczenia mogą być wykonywane na oddzielnym serwerze, dzięki czemu nie obciążają głównej bazy danych i nie wpływają na jej wydajność.


\subsection{Mechanizmy replikacji}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:mechanizmy-replikacji}}
\sphinxAtStartPar
Replikacja w bazach danych polega na kopiowaniu i synchronizowaniu danych oraz obiektów z serwera głównego (master) na serwer zapasowy (slave), aby zapewnić spójność i wysoką dostępność danych.

\sphinxAtStartPar
Mechanizm replikacji MySQL działa w następujący sposób:
\sphinxhyphen{} Serwer główny zapisuje wszystkie zmiany w plikach binarnych (bin\sphinxhyphen{}logach), które zawierają instrukcje wykonane na masterze.
\sphinxhyphen{} Specjalny wątek na masterze przesyła bin\sphinxhyphen{}logi do serwerów slave.
\sphinxhyphen{} Wątek SQL, który odczytuje relay\sphinxhyphen{}logi i wykonuje zapisane w nich zapytania, aby odtworzyć zmiany w lokalnej bazie.
\sphinxhyphen{} Wątek I/O, który odbiera bin\sphinxhyphen{}logi i zapisuje je do relay\sphinxhyphen{}logów (tymczasowych plików na slave).
Podsumowując, replikacja w MySQL polega na automatycznym przesyłaniu i odtwarzaniu zmian, dzięki czemu baza na serwerze zapasowym jest na bieżąco synchronizowana z bazą główną.


\subsection{Rodzaje mechanizmów replikacji}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:rodzaje-mechanizmow-replikacji}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Replikacja oparta na zapisie (Write\sphinxhyphen{}Ahead Logging): Ten typ replikacji jest często wykorzystywany w systemach takich jak PostgreSQL. Polega na tym, że zmiany w transakcjach są najpierw zapisywane w dzienniku zapisu, a następnie jego zawartość jest kopiowana na serwery repliki.

\item {} 
\sphinxAtStartPar
Replikacja oparta na zrzutach (Snapshot\sphinxhyphen{}Based Replication): W niektórych systemach stosuje się okresowe tworzenie pełnych zrzutów bazy danych, które są przesyłane do serwerów repliki.

\item {} 
\sphinxAtStartPar
Replikacja oparta na transakcjach (Transaction\sphinxhyphen{}Based Replication): W tym modelu każda transakcja jest przekazywana i odtwarzana na serwerach repliki, co sprawdza się w systemach wymagających silnej spójności.

\item {} 
\sphinxAtStartPar
Replikacja asynchroniczna i synchroniczna: W replikacji asynchronicznej dane najpierw trafiają do głównej bazy, a potem na repliki. W replikacji synchronicznej zapisy są wykonywane jednocześnie na serwerze głównym i replikach.

\item {} 
\sphinxAtStartPar
Replikacja dwukierunkowa (Bi\sphinxhyphen{}Directional Replication): Pozwala na wprowadzanie zmian na dowolnym z serwerów repliki, które są synchronizowane z pozostałymi, co jest szczególnie użyteczne w systemach o wysokiej dostępności.

\end{itemize}

\sphinxAtStartPar
PostgreSQL oferuje różne metody replikacji, w tym opartą na zapisie (WAL), asynchroniczną, synchroniczną oraz replikację logiczną. Mechanizm WAL zapewnia bezpieczeństwo danych przez zapisywanie wszystkich zmian w dzienniku przed ich zastosowaniem i przesyłanie go na repliki. W trybie asynchronicznym dane trafiają najpierw na serwer główny, a potem na repliki, natomiast w trybie synchronicznym zapisy są realizowane jednocześnie. Dodatkowo, replikacja logiczna umożliwia kopiowanie wybranych tabel lub baz, co jest przydatne w przypadku bardzo dużych zbiorów danych.


\subsection{Zalety i Wady replikacji}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:zalety-i-wady-replikacji}}
\sphinxAtStartPar
Zalety:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Zwiększenie wydajności i dostępności: Replikacja pozwala rozłożyć obciążenie zapytań na wiele serwerów, co poprawia wydajność systemu. Użytkownicy mogą kierować zapytania do najbliższych serwerów repliki, skracając czas odpowiedzi. W przypadku awarii jednego serwera pozostałe repliki kontynuują obsługę zapytań, zapewniając wysoką dostępność.

\item {} 
\sphinxAtStartPar
Ochrona danych: Replikacja wspiera tworzenie kopii zapasowych i odzyskiwanie danych. W razie awarii głównej bazy replika może służyć jako źródło do odtworzenia informacji.

\item {} 
\sphinxAtStartPar
Rozproszenie danych geograficzne: Umożliwia przenoszenie danych do różnych lokalizacji. Międzynarodowa firma może replikować dane między oddziałami, co pozwala lokalnym użytkownikom na szybki dostęp.

\item {} 
\sphinxAtStartPar
Wsparcie analizy i raportowania: Dane z replik mogą być wykorzystywane do analiz i raportów, co odciąża główną bazę danych i utrzymuje jej wysoką wydajność.

\end{itemize}

\sphinxAtStartPar
Wady:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Replikacja nie gwarantuje, że po wykonaniu operacji dane na serwerze głównym zostaną w pełni odzwierciedlone na serwerze zapasowym.

\item {} 
\sphinxAtStartPar
Mechanizm nie chroni przed skutkami działań, takich jak przypadkowe usunięcie tabeli (DROP TABLE).

\end{itemize}


\section{Kontrola dostępu i limity systemowe}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:kontrola-dostepu-i-limity-systemowe}}
\sphinxAtStartPar
Limity systemowe w zarządzaniu bazami danych określają maksymalną ilość zasobów, które system jest w stanie obsłużyć. Są one ustalane przez system zarządzania bazą danych (DBMS) i zależą od zasobów sprzętowych oraz konfiguracji. Na przykład w Azure SQL Database limity zasobów różnią się w zależności od wybranego poziomu cenowego. W MySQL maksymalny rozmiar tabeli jest zwykle ograniczony przez parametry systemu operacyjnego dotyczące wielkości plików.

\sphinxAtStartPar
Kontrola dostępu użytkowników w DBMS to mechanizm umożliwiający lub blokujący dostęp do danych. Składa się z dwóch elementów: uwierzytelniania, czyli potwierdzania tożsamości użytkownika, oraz autoryzacji, czyli ustalania jego uprawnień. Wyróżnia się modele takie jak Kontrola Dostępu Uzależniona (DAC), Obowiązkowa (MAC), oparta na Rolach (RBAC) czy na Atrybutach (ABAC).

\sphinxAtStartPar
PostgreSQL oferuje narzędzia do zarządzania limitami systemowymi i kontrolą dostępu. Administratorzy mogą ustawiać parametry takie jak maksymalna liczba połączeń, limity pamięci, maksymalny rozmiar pliku danych czy wielkość tabeli. W zakresie kontroli dostępu PostgreSQL zapewnia mechanizmy uwierzytelniania i autoryzacji. Administratorzy mogą tworzyć role i nadawać uprawnienia dotyczące baz danych, schematów, tabel i kolumn. PostgreSQL obsługuje uwierzytelnianie oparte na hasłach i certyfikatach SSL, umożliwiając skuteczne zarządzanie bezpieczeństwem i poufnością danych.


\section{Testowanie wydajności sprzętu na poziomie OS}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:testowanie-wydajnosci-sprzetu-na-poziomie-os}}
\sphinxAtStartPar
Testy wydajności kluczowych komponentów sprzętowych na poziomie systemu operacyjnego są niezbędne do optymalizacji działania baz danych. Obejmują oceny pamięci RAM, procesora (CPU) oraz dysków twardych (HDD) i SSD — elementów mających największy wpływ na szybkość i efektywność systemu. Analiza wyników pomaga wskazać elementy wymagające modernizacji lub optymalizacji, co pozwala podnieść ogólną wydajność systemu bazodanowego, niezależnie od używanego oprogramowania.

\sphinxAtStartPar
Testy pamięci RAM pozwalają zmierzyć jej szybkość i stabilność, co przekłada się na wydajność bazy danych. W tym celu często stosuje się narzędzia takie jak MemTest86.

\sphinxAtStartPar
Testy procesora oceniają jego moc obliczeniową i zdolność do przetwarzania zapytań. Popularnym programem jest Cinebench R23.

\sphinxAtStartPar
Testy dysków sprawdzają szybkość operacji odczytu i zapisu, co jest kluczowe, ponieważ baza danych przechowuje dane na nośnikach dyskowych. Do pomiarów wykorzystuje się narzędzia takie jak CrystalDiskMark 8 czy Acronis Drive Monitor.


\section{Podsumowanie}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:podsumowanie}}
\sphinxAtStartPar
W pracy przedstawiono kluczowe zagadnienia związane z zarządzaniem bazami danych, w tym rodzaje replikacji, metody kontroli dostępu użytkowników, limity systemowe oraz znaczenie testów wydajności komponentów sprzętowych. Omówiono zalety i wady replikacji, takie jak zwiększenie dostępności czy ryzyko niespójności danych. Scharakteryzowano mechanizmy uwierzytelniania i autoryzacji, które zapewniają bezpieczeństwo informacji, oraz wskazano, jak limity zasobów wpływają na działanie systemu. Zwrócono także uwagę na rolę testów pamięci RAM, procesora i dysków w optymalizacji wydajności środowiska bazodanowego. Całość podkreśla znaczenie świadomego projektowania i utrzymywania infrastruktury baz danych w celu zapewnienia jej niezawodności, bezpieczeństwa i wysokiej efektywności pracy.


\section{Bibliografia}
\label{\detokenize{Wydajnosc-Skalowanie-i-Replikacja/index:bibliografia}}
\sphinxAtStartPar
{[}1{]} PostgreSQL Documentation – Performance Tips
\sphinxurl{https://www.postgresql.org/docs/current/performance-tips.html}

\sphinxAtStartPar
{[}2{]} SQLite Documentation – Query Optimizer Overview
\sphinxurl{https://sqlite.org/optoverview.html}

\sphinxAtStartPar
{[}3{]} F. Hecht, Scaling Database Systems
\sphinxurl{https://www.cockroachlabs.com/docs/stable/scaling-your-database.html}

\sphinxAtStartPar
{[}4{]} DigitalOcean, How To Optimize Queries and Tables in PostgreSQL
\sphinxurl{https://www.digitalocean.com/community/tutorials/how-to-optimize-queries-and-tables-in-postgresql}

\sphinxAtStartPar
{[}5{]} PostgreSQL Documentation – High Availability, Load Balancing, and Replication
\sphinxurl{https://www.postgresql.org/docs/current/different-replication-solutions.html}

\sphinxAtStartPar
{[}6{]} SQLite Documentation – How Indexes Work
\sphinxurl{https://www.sqlite.org/queryplanner.html}

\sphinxAtStartPar
{[}7{]} Redgate, The Importance of Database Performance Testing
\sphinxurl{https://www.red-gate.com/simple-talk/sql/performance/the-importance-of-database-performance-testing/}

\sphinxAtStartPar
{[}8{]} Materiały kursowe przedmiotu „Bazy Danych”, Politechnika Wrocławska, Piotr Czaja.

\sphinxstepscope


\chapter{Sprzęt dla baz danych}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:sprzet-dla-baz-danych}}\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych::doc}}

\section{Wstęp}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:wstep}}
\sphinxAtStartPar
Systemy zarządzania bazami danych (DBMS) są fundamentem współczesnych aplikacji i usług – od rozbudowanych systemów transakcyjnych, przez aplikacje internetowe, aż po urządzenia mobilne czy systemy wbudowane. W zależności od zastosowania i skali projektu, wybór odpowiedniego silnika bazodanowego oraz towarzyszącej mu infrastruktury sprzętowej ma kluczowe znaczenie dla zapewnienia wydajności, stabilności i niezawodności systemu


\section{Sprzęt dla bazy danych PostgreSQL}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:sprzet-dla-bazy-danych-postgresql}}
\sphinxAtStartPar
PostgreSQL to potężny system RDBMS, ceniony za swoją skalowalność, wsparcie dla zaawansowanych zapytań i dużą elastyczność. Jego efektywne działanie zależy w dużej mierze od odpowiednio dobranej infrastruktury sprzętowej.


\subsection{Procesor}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:procesor}}
\sphinxAtStartPar
PostgreSQL obsługuje wiele wątków, jednak pojedyncze zapytania zazwyczaj są wykonywane jednordzeniowo. Z tego względu optymalny procesor powinien cechować się zarówno wysokim taktowaniem jak i odpowiednią liczbą rdzeni do równoczesnej obsługi wielu zapytań. W środowiskach produkcyjnych najczęściej wykorzystuje się procesory serwerowe takie jak Intel Xeon czy AMD EPYC, które oferują zarówno wydajność, jak i niezawodność.


\subsection{Pamięć operacyjna}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:pamiec-operacyjna}}
\sphinxAtStartPar
RAM odgrywa istotną rolę w przetwarzaniu danych, co znacząco wpływa na wydajność operacji. PostgreSQL efektywnie wykorzystuje dostępne zasoby pamięci do cache’owania, dlatego im więcej pamięci RAM tym lepiej. W praktyce, minimalne pojemności dla mniejszych baz to około 16–32 GB, natomiast w środowiskach produkcyjnych i analitycznych często stosuje się od 64 GB do nawet kilkuset.


\subsection{Przestrzeń dyskowa}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:przestrzen-dyskowa}}
\sphinxAtStartPar
Dyski twarde to krytyczny element wpływający na szybkość działania bazy. Zdecydowanie zaleca się korzystanie z dysków SSD (najlepiej NVMe), które zapewniają wysoką przepustowość i niskie opóźnienia. Warto zastosować konfigurację RAID 10, która łączy szybkość z redundancją.


\subsection{Sieć internetowa}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:siec-internetowa}}
\sphinxAtStartPar
W przypadku PostgreSQL działającego w klastrach, środowiskach chmurowych lub przy replikacji danych, wydajne połączenie sieciowe ma kluczowe znaczenie. Standardem są interfejsy 1 Gb/s, lecz w dużych bazach danych stosuje się nawet 10 Gb/s i więcej. Liczy się nie tylko przepustowość, ale też niskie opóźnienia i niezawodność.


\subsection{Zasilanie}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:zasilanie}}
\sphinxAtStartPar
Niezawodność zasilania to jeden z filarów bezpieczeństwa danych. Zaleca się stosowanie zasilaczy redundantnych oraz zasilania awaryjnego UPS, które umożliwia bezpieczne wyłączenie systemu w przypadku awarii. Można użyć własnych generatorów prądu.


\subsection{Chłodzenie}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:chlodzenie}}
\sphinxAtStartPar
Intensywna praca serwera PostgreSQL generuje duże ilości ciepła. Wydajne chłodzenie powietrzne, a często nawet cieczowe jest potrzebne by utrzymać stabilność systemu i przedłużyć żywotność komponentów. W profesjonalnych serwerowniach stosuje się zaawansowane systemy klimatyzacji i kontroli termicznej.


\section{Sprzęt dla bazy danych SQLite}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:sprzet-dla-bazy-danych-sqlite}}
\sphinxAtStartPar
SQLite to lekki, samodzielny silnik bazodanowy, nie wymagający uruchamiania oddzielnego serwera. Znajduje zastosowanie m.in. w aplikacjach mobilnych, przeglądarkach internetowych, systemach IoT czy oprogramowaniu wbudowanym.


\subsection{Procesor}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:id1}}
\sphinxAtStartPar
SQLite działa lokalnie na urządzeniu użytkownika. Dla prostych operacji wystarczy procesor z jednym, albo dwoma rdzeniami. W bardziej wymagających zastosowaniach (np. filtrowanie dużych zbiorów danych) przyda się szybszy CPU. Wielowątkowość nie daje istotnych korzyści.


\subsection{Pamięć operacyjna}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:id2}}
\sphinxAtStartPar
SQLite potrzebuje niewielkiej ilości pamięci RAM w wielu przypadkach wystarcza 256MB do 1GB. Jednak dla komfortowej pracy z większymi zbiorami danych warto zapewnić nieco więcej pamięci, czyli 2 GB lub więcej, szczególnie w aplikacjach desktopowych lub mobilnych.


\subsection{Przestrzeń dyskowa}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:id3}}
\sphinxAtStartPar
Dane w SQLite zapisywane są w jednym pliku. Wydajność operacji zapisu/odczytu zależy od nośnika. Dyski SSD lub szybkie karty pamięci są preferowane. W przypadku urządzeń wbudowanych, kluczowe znaczenie ma trwałość nośnika, zwłaszcza przy częstym zapisie danych.


\subsection{Sieć internetowa}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:id4}}
\sphinxAtStartPar
SQLite nie wymaga połączeń sieciowych – działa lokalnie. W sytuacjach, gdzie dane są synchronizowane z serwerem lub przenoszone przez sieć (np. w aplikacjach mobilnych), znaczenie ma jakość połączenia (Wi\sphinxhyphen{}Fi, LTE), choć wpływa to bardziej na komfort użytkowania aplikacji niż na samą bazę.


\subsection{Zasilanie}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:id5}}
\sphinxAtStartPar
W systemach mobilnych i IoT efektywne zarządzanie energią jest kluczowe. Aplikacje powinny ograniczać zbędne operacje odczytu i zapisu, by niepotrzebnie nie obciążać procesora i nie zużywać baterii. W zastosowaniach stacjonarnych problem ten zazwyczaj nie występuje.


\subsection{Chłodzenie}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:id6}}
\sphinxAtStartPar
SQLite nie generuje dużego obciążenia cieplnego. W większości przypadków wystarczy pasywne chłodzenie w zamkniętych obudowach, lecz warto zadbać o minimalny przepływ powietrza.


\section{Podsumowanie}
\label{\detokenize{Sprzet-dla-bazy-danych/source/SprzetDlaBazyDanych:podsumowanie}}
\sphinxAtStartPar
Zarówno PostgreSQL, jak i SQLite pełnią istotne role w ekosystemie baz danych, lecz ich wymagania sprzętowe są diametralnie różne. PostgreSQL, jako system serwerowy, wymaga zaawansowanego i wydajnego sprzętu: mocnych procesorów, dużej ilości RAM, szybkich dysków, niezawodnej sieci, zasilania i chłodzenia.
Z kolei SQLite działa doskonale na skromniejszych zasobach, stawiając na lekkość i prostotę implementacyjną.
Dostosowanie sprzętu do konkretnego silnika DBMS i charakterystyki aplikacji pozwala nie tylko na osiągnięcie optymalnej wydajności, ale też gwarantuje stabilność i bezpieczeństwo działania całego systemu.

\sphinxstepscope


\chapter{Sprawozdanie: Konfiguracja i Zarządzanie Bazą Danych}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:sprawozdanie-konfiguracja-i-zarzadzanie-baza-danych}}\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych::doc}}\begin{quote}\begin{description}
\sphinxlineitem{Authors}\begin{itemize}
\item {} 
\sphinxAtStartPar
Piotr Domagała

\item {} 
\sphinxAtStartPar
Piotr Kotuła

\item {} 
\sphinxAtStartPar
Dawid Pasikowski

\end{itemize}

\end{description}\end{quote}


\section{1. Konfiguracja bazy danych}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:konfiguracja-bazy-danych}}
\sphinxAtStartPar
Wprowadzenie do tematu konfiguracji bazy danych obejmuje podstawowe informacje na temat zarządzania i dostosowywania ustawień baz danych w systemach informatycznych. Konfiguracja ta jest kluczowa dla zapewnienia bezpieczeństwa, wydajności oraz stabilności działania aplikacji korzystających z bazy danych. Obejmuje m.in. określenie parametrów połączenia, zarządzanie użytkownikami, uprawnieniami oraz optymalizację działania systemu bazodanowego.


\section{2. Lokalizacja i struktura katalogów}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:lokalizacja-i-struktura-katalogow}}
\sphinxAtStartPar
Każda baza danych przechowuje swoje pliki w określonych lokalizacjach systemowych, zależnie od używanego silnika. Przykładowe lokalizacje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{PostgreSQL}: \sphinxcode{\sphinxupquote{/var/lib/pgsql/data}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{MySQL}: \sphinxcode{\sphinxupquote{/var/lib/mysql}}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{SQL Server}: \sphinxcode{\sphinxupquote{C:\textbackslash{}Program Files\textbackslash{}Microsoft SQL Server}}

\end{itemize}

\sphinxAtStartPar
Struktura katalogów obejmuje katalog główny bazy danych oraz podkatalogi na pliki danych, logi, kopie zapasowe i pliki konfiguracyjne.

\sphinxAtStartPar
\sphinxstylestrong{Przykład}: W dużych środowiskach produkcyjnych często stosuje się osobne dyski do przechowywania plików danych i logów transakcyjnych. Takie rozwiązanie pozwala na zwiększenie wydajności operacji zapisu oraz minimalizowanie ryzyka utraty danych.

\sphinxAtStartPar
\sphinxstylestrong{Dobra praktyka}: Zaleca się, aby katalogi z danymi i logami były regularnie monitorowane pod kątem dostępnego miejsca na dysku. Przepełnienie któregoś z nich może doprowadzić do zatrzymania pracy bazy danych.


\section{3. Katalog danych}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:katalog-danych}}
\sphinxAtStartPar
Jest to miejsce, gdzie fizycznie przechowywane są wszystkie pliki związane z bazą danych, takie jak:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Pliki tabel i indeksów

\item {} 
\sphinxAtStartPar
Dzienniki transakcji

\item {} 
\sphinxAtStartPar
Pliki tymczasowe

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Przykładowo}: W PostgreSQL katalog danych to \sphinxcode{\sphinxupquote{/var/lib/pgsql/data}}, gdzie znajdują się zarówno pliki z danymi, jak i główny plik konfiguracyjny \sphinxcode{\sphinxupquote{postgresql.conf}}.

\sphinxAtStartPar
\sphinxstylestrong{Wskazówka}: Dostęp do katalogu danych powinien być ograniczony tylko do uprawnionych użytkowników systemu, co zwiększa bezpieczeństwo i zapobiega przypadkowym lub celowym modyfikacjom plików bazy.


\section{4. Podział konfiguracji na podpliki}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:podzial-konfiguracji-na-podpliki}}
\sphinxAtStartPar
Konfiguracja systemu bazodanowego może być rozbita na kilka mniejszych, wyspecjalizowanych plików, np.:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{postgresql.conf}} – główne ustawienia serwera

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_hba.conf}} – reguły autoryzacji i dostępu

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_ident.conf}} – mapowanie użytkowników systemowych na użytkowników PostgreSQL

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Przykład}: Jeśli administrator chce zmienić jedynie sposób autoryzacji użytkowników, edytuje tylko plik \sphinxcode{\sphinxupquote{pg\_hba.conf}}, bez ryzyka wprowadzenia niezamierzonych zmian w innych częściach konfiguracji.

\sphinxAtStartPar
\sphinxstylestrong{Dobra praktyka}: Rozdzielenie konfiguracji na podpliki ułatwia zarządzanie, pozwala szybciej lokalizować błędy i minimalizuje ryzyko konfliktów podczas aktualizacji lub wdrażania zmian.


\section{5. Katalog Konfiguracyjny}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:katalog-konfiguracyjny}}
\sphinxAtStartPar
To miejsce przechowywania wszystkich plików konfiguracyjnych bazy danych, takich jak główny plik konfiguracyjny, pliki z ustawieniami użytkowników, uprawnień czy harmonogramów zadań.

\sphinxAtStartPar
Typowe lokalizacje to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{/etc}} (np. \sphinxcode{\sphinxupquote{my.cnf}} dla MySQL)

\item {} 
\sphinxAtStartPar
Katalog danych bazy (np. \sphinxcode{\sphinxupquote{/var/lib/pgsql/data}} dla PostgreSQL)

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Przykład}: W przypadku awarii systemu administrator może szybko przywrócić działanie bazy, kopiując wcześniej zapisane pliki konfiguracyjne z katalogu konfiguracyjnego.

\sphinxAtStartPar
\sphinxstylestrong{Wskazówka}: Regularne wykonywanie kopii zapasowych katalogu konfiguracyjnego jest kluczowe – utrata tych plików może uniemożliwić uruchomienie bazy danych lub spowodować utratę ważnych ustawień systemowych.


\section{6. Katalog logów i struktura katalogów w PostgreSQL}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:katalog-logow-i-struktura-katalogow-w-postgresql}}
\sphinxAtStartPar
\sphinxstylestrong{Katalog logów}
PostgreSQL zapisuje logi w różnych lokalizacjach, zależnie od systemu operacyjnego:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Na Debianie/Ubuntu: \sphinxcode{\sphinxupquote{/var/log/postgresql}}

\item {} 
\sphinxAtStartPar
Na Red Hat/CentOS: \sphinxcode{\sphinxupquote{/var/lib/pgsql/<wersja>/data/pg\_log}}

\end{itemize}

\sphinxAtStartPar
> Uwaga: Aby zapisywać logi do pliku, należy upewnić się, że opcja \sphinxcode{\sphinxupquote{logging\_collector}} jest włączona w pliku \sphinxcode{\sphinxupquote{postgresql.conf}}.

\sphinxAtStartPar
\sphinxstylestrong{Struktura katalogów PostgreSQL}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{base}\PYG{o}{/}         \PYG{c+c1}{\PYGZsh{} dane użytkownika – jedna podkatalog dla każdej bazy danych}
\PYG{k}{global}\PYG{o}{/}       \PYG{c+c1}{\PYGZsh{} dane wspólne dla wszystkich baz (np. użytkownicy)}
\PYG{n}{pg\PYGZus{}wal}\PYG{o}{/}       \PYG{c+c1}{\PYGZsh{} pliki WAL (Write\PYGZhy{}Ahead Logging)}
\PYG{n}{pg\PYGZus{}stat}\PYG{o}{/}      \PYG{c+c1}{\PYGZsh{} statystyki działania serwera}
\PYG{n}{pg\PYGZus{}log}\PYG{o}{/}       \PYG{c+c1}{\PYGZsh{} logi (jeśli skonfigurowane)}
\PYG{n}{pg\PYGZus{}tblspc}\PYG{o}{/}    \PYG{c+c1}{\PYGZsh{} dowiązania do tablespace’ów}
\PYG{n}{pg\PYGZus{}twophase}\PYG{o}{/}  \PYG{c+c1}{\PYGZsh{} dane dla transakcji dwufazowych}
\PYG{n}{postgresql}\PYG{o}{.}\PYG{n}{conf}  \PYG{c+c1}{\PYGZsh{} główny plik konfiguracyjny}
\PYG{n}{pg\PYGZus{}hba}\PYG{o}{.}\PYG{n}{conf}      \PYG{c+c1}{\PYGZsh{} kontrola dostępu}
\PYG{n}{pg\PYGZus{}ident}\PYG{o}{.}\PYG{n}{conf}    \PYG{c+c1}{\PYGZsh{} mapowanie użytkowników systemowych na bazodanowych}
\end{sphinxVerbatim}


\section{7. Przechowywanie i lokalizacja plików konfiguracyjnych}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:przechowywanie-i-lokalizacja-plikow-konfiguracyjnych}}
\sphinxAtStartPar
Główne pliki konfiguracyjne:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{postgresql.conf}} – konfiguracja instancji PostgreSQL (parametry wydajności, logowania, lokalizacji itd.)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_hba.conf}} – kontrola dostępu (adresy IP, użytkownicy, metody autoryzacji)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_ident.conf}} – mapowanie użytkowników systemowych na użytkowników bazodanowych

\end{itemize}


\section{8. Podstawowe parametry konfiguracyjne}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:podstawowe-parametry-konfiguracyjne}}
\sphinxAtStartPar
\sphinxstylestrong{Słuchanie połączeń:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{listen\PYGZus{}addresses} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{localhost}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{port} \PYG{o}{=} \PYG{l+m+mi}{5432}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Pamięć i wydajność:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{shared\PYGZus{}buffers} \PYG{o}{=} \PYG{l+m+mi}{512}\PYG{n}{MB}         \PYG{c+c1}{\PYGZsh{} pamięć współdzielona}
\PYG{n}{work\PYGZus{}mem} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{n}{MB}                 \PYG{c+c1}{\PYGZsh{} pamięć na operacje sortowania/złączeń}
\PYG{n}{maintenance\PYGZus{}work\PYGZus{}mem} \PYG{o}{=} \PYG{l+m+mi}{64}\PYG{n}{MB}    \PYG{c+c1}{\PYGZsh{} dla operacji VACUUM, CREATE INDEX}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Autovacuum:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{autovacuum} \PYG{o}{=} \PYG{n}{on}
\PYG{n}{autovacuum\PYGZus{}naptime} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{n+nb}{min}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Konfiguracja pliku} \sphinxcode{\sphinxupquote{pg\_hba.conf}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} TYPE  DATABASE  USER  ADDRESS         METHOD}
\PYG{n}{local}   \PYG{n+nb}{all}       \PYG{n+nb}{all}   \PYG{n}{md5}
\PYG{n}{host}    \PYG{n+nb}{all}       \PYG{n+nb}{all}   \PYG{l+m+mf}{192.168}\PYG{l+m+mf}{.0}\PYG{l+m+mf}{.0}\PYG{o}{/}\PYG{l+m+mi}{24}  \PYG{n}{md5}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Konfiguracja pliku} \sphinxcode{\sphinxupquote{pg\_ident.conf}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} MAPNAME      SYSTEM\PYGZhy{}USERNAME   PG\PYGZhy{}USERNAME}
\PYG{n}{local\PYGZus{}users}  \PYG{n}{ubuntu}            \PYG{n}{postgres}
\PYG{n}{local\PYGZus{}users}  \PYG{n}{jan\PYGZus{}kowalski}      \PYG{n}{janek\PYGZus{}db}
\end{sphinxVerbatim}

\sphinxAtStartPar
Można użyć tej mapy w pliku \sphinxcode{\sphinxupquote{pg\_hba.conf}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{local}   \PYG{n+nb}{all}     \PYG{n+nb}{all}     \PYG{n}{peer} \PYG{n+nb}{map}\PYG{o}{=}\PYG{n}{local\PYGZus{}users}
\end{sphinxVerbatim}


\section{9. Wstęp teoretyczny}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:wstep-teoretyczny}}
\sphinxAtStartPar
Systemy zarządzania bazą danych (DBMS – \sphinxstyleemphasis{Database Management System}) umożliwiają tworzenie, modyfikowanie i zarządzanie danymi. Ułatwiają organizację danych, zapewniają integralność, bezpieczeństwo oraz możliwość jednoczesnego dostępu wielu użytkowników.


\subsection{9.1 Klasyfikacja systemów zarządzania bazą danych}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:klasyfikacja-systemow-zarzadzania-baza-danych}}
\sphinxAtStartPar
Systemy DBMS można klasyfikować według:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Architektura działania:}
\sphinxhyphen{} \sphinxstyleemphasis{Klient\sphinxhyphen{}serwer} – system działa jako niezależna usługa (np. PostgreSQL).
\sphinxhyphen{} \sphinxstyleemphasis{Osadzony (embedded)} – baza danych jest integralną częścią aplikacji (np. SQLite).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rodzaj danych i funkcjonalność:}
\sphinxhyphen{} \sphinxstyleemphasis{Relacyjne (RDBMS)} – oparte na tabelach, kluczach i SQL.
\sphinxhyphen{} \sphinxstyleemphasis{Nierelacyjne (NoSQL)} – oparte na dokumentach, modelu klucz\sphinxhyphen{}wartość lub grafach.

\end{itemize}

\sphinxAtStartPar
Oba systemy – \sphinxstylestrong{SQLite} oraz \sphinxstylestrong{PostgreSQL} – należą do relacyjnych baz danych, lecz różnią się architekturą, wydajnością, konfiguracją i przeznaczeniem.


\subsection{9.2 SQLite}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:sqlite}}
\sphinxAtStartPar
SQLite to lekka, bezserwerowa baza danych typu embedded, gdzie cała baza znajduje się w jednym pliku. Dzięki temu jest bardzo wygodna przy tworzeniu aplikacji lokalnych, mobilnych oraz projektów prototypowych.

\sphinxAtStartPar
\sphinxstylestrong{Cechy SQLite:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Brak osobnego procesu serwera – baza działa w kontekście aplikacji.

\item {} 
\sphinxAtStartPar
Niskie wymagania systemowe – brak potrzeby instalacji i konfiguracji.

\item {} 
\sphinxAtStartPar
Baza przechowywana jako pojedynczy plik (\sphinxstyleemphasis{.sqlite} lub \sphinxstyleemphasis{.db}).

\item {} 
\sphinxAtStartPar
Pełna obsługa SQL (z pewnymi ograniczeniami) – wspiera standard SQL\sphinxhyphen{}92.

\item {} 
\sphinxAtStartPar
Ograniczona skalowalność przy wielu użytkownikach.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Zastosowanie:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Aplikacje desktopowe (np. Firefox, VS Code).

\item {} 
\sphinxAtStartPar
Aplikacje mobilne (Android, iOS).

\item {} 
\sphinxAtStartPar
Małe i średnie systemy bazodanowe.

\end{itemize}


\subsection{9.3 PostgreSQL}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:postgresql}}
\sphinxAtStartPar
PostgreSQL to zaawansowany system relacyjnej bazy danych typu klient\sphinxhyphen{}serwer, rozwijany jako projekt open\sphinxhyphen{}source. Zapewnia pełne wsparcie dla SQL oraz liczne rozszerzenia (np. typy przestrzenne, JSON).

\sphinxAtStartPar
\sphinxstylestrong{Cechy PostgreSQL:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Architektura klient\sphinxhyphen{}serwer – działa jako oddzielny proces.

\item {} 
\sphinxAtStartPar
Wysoka skalowalność i niezawodność – obsługuje wielu użytkowników, złożone zapytania, replikację.

\item {} 
\sphinxAtStartPar
Obsługa transakcji, MVCC, indeksowania oraz zarządzania uprawnieniami.

\item {} 
\sphinxAtStartPar
Rozszerzalność – możliwość definiowania własnych typów danych, funkcji i procedur.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Konfiguracja:}
Plikami konfiguracyjnymi są:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{postgresql.conf}} – ustawienia ogólne (port, ścieżki, pamięć, logi).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_hba.conf}} – reguły autoryzacji.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_ident.conf}} – mapowanie użytkowników systemowych na bazodanowych.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Zastosowanie:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Systemy biznesowe, bankowe, analityczne.

\item {} 
\sphinxAtStartPar
Aplikacje webowe i serwery aplikacyjne.

\item {} 
\sphinxAtStartPar
Środowiska o wysokich wymaganiach bezpieczeństwa i kontroli dostępu.

\end{itemize}


\subsection{9.4 Cel użycia obu systemów}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:cel-uzycia-obu-systemow}}
\sphinxAtStartPar
W ramach zajęć wykorzystano zarówno \sphinxstylestrong{SQLite} (dla szybkiego startu i analizy zapytań bez instalacji serwera), jak i \sphinxstylestrong{PostgreSQL} (dla nauki konfiguracji, zarządzania użytkownikami, uprawnieniami oraz obsługi złożonych operacji).


\section{10. Zarządzanie konfiguracją w PostgreSQL}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:zarzadzanie-konfiguracja-w-postgresql}}
\sphinxAtStartPar
PostgreSQL oferuje rozbudowany i elastyczny mechanizm konfiguracji, umożliwiający precyzyjne dostosowanie działania bazy danych do potrzeb użytkownika oraz środowiska (lokalnego, deweloperskiego, testowego czy produkcyjnego).


\subsection{10.1 Pliki konfiguracyjne}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:pliki-konfiguracyjne}}
\sphinxAtStartPar
Główne pliki konfiguracyjne PostgreSQL:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{postgresql.conf} – ustawienia dotyczące pamięci, sieci, logowania, autovacuum, planowania zapytań.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pg\_hba.conf} – definiuje metody uwierzytelniania i dostęp z określonych adresów.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pg\_ident.conf} – mapowanie nazw użytkowników systemowych na użytkowników PostgreSQL.

\end{itemize}

\sphinxAtStartPar
Pliki te zazwyczaj znajdują się w katalogu danych (np. \sphinxcode{\sphinxupquote{/var/lib/postgresql/15/main/}} lub \sphinxcode{\sphinxupquote{/etc/postgresql/15/main/}}).


\subsection{10.2 Przykładowe kluczowe parametry \sphinxstyleliteralintitle{\sphinxupquote{postgresql.conf}}}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:przykladowe-kluczowe-parametry-postgresql-conf}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Parametr}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Opis}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
shared\_buffers
&
\sphinxAtStartPar
Ilość pamięci RAM przeznaczona na bufor danych (rekomendacja: 25–40\% RAM).
\\
\sphinxhline
\sphinxAtStartPar
work\_mem
&
\sphinxAtStartPar
Pamięć dla pojedynczej operacji zapytania (np. sortowania).
\\
\sphinxhline
\sphinxAtStartPar
maintenance\_work\_mem
&
\sphinxAtStartPar
Pamięć dla operacji administracyjnych (np. VACUUM, CREATE INDEX).
\\
\sphinxhline
\sphinxAtStartPar
effective\_cache\_size
&
\sphinxAtStartPar
Szacunkowa ilość pamięci dostępnej na cache systemu operacyjnego.
\\
\sphinxhline
\sphinxAtStartPar
max\_connections
&
\sphinxAtStartPar
Maksymalna liczba jednoczesnych połączeń z bazą danych.
\\
\sphinxhline
\sphinxAtStartPar
log\_directory
&
\sphinxAtStartPar
Katalog, w którym zapisywane są logi PostgreSQL.
\\
\sphinxhline
\sphinxAtStartPar
autovacuum
&
\sphinxAtStartPar
Włącza lub wyłącza automatyczne odświeżanie nieużywanych wierszy.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{10.3 Sposoby zmiany konfiguracji}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:sposoby-zmiany-konfiguracji}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Edycja pliku} \sphinxcode{\sphinxupquote{postgresql.conf}}

\sphinxAtStartPar
Zmiany są trwałe, ale wymagają restartu serwera (w niektórych przypadkach wystarczy reload).

\sphinxAtStartPar
\sphinxstylestrong{Przykład:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{shared\PYGZus{}buffers} \PYG{o}{=} \PYG{l+m+mi}{512}\PYG{n}{MB}
\PYG{n}{work\PYGZus{}mem} \PYG{o}{=} \PYG{l+m+mi}{64}\PYG{n}{MB}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dynamiczna zmiana poprzez SQL}

\sphinxAtStartPar
\sphinxstylestrong{Przykład:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ALTER} \PYG{n}{SYSTEM} \PYG{n}{SET} \PYG{n}{work\PYGZus{}mem} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{64MB}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{SELECT} \PYG{n}{pg\PYGZus{}reload\PYGZus{}conf}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  \PYG{c+c1}{\PYGZsh{} ładowanie zmian bez restartu}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Tymczasowa zmiana dla jednej sesji}

\sphinxAtStartPar
\sphinxstylestrong{Przykład:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SET} \PYG{n}{work\PYGZus{}mem} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{128MB}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\end{enumerate}


\subsection{10.4 Sprawdzanie konfiguracji}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:sprawdzanie-konfiguracji}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Aby sprawdzić aktualną wartość parametru:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SHOW} \PYG{n}{work\PYGZus{}mem}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Pobranie szczegółowych informacji:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SELECT} \PYG{n}{name}\PYG{p}{,} \PYG{n}{setting}\PYG{p}{,} \PYG{n}{unit}\PYG{p}{,} \PYG{n}{context}\PYG{p}{,} \PYG{n}{source}
\PYG{n}{FROM} \PYG{n}{pg\PYGZus{}settings}
\PYG{n}{WHERE} \PYG{n}{name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{work\PYGZus{}mem}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Wylistowanie parametrów wymagających restartu serwera:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SELECT} \PYG{n}{name} \PYG{n}{FROM} \PYG{n}{pg\PYGZus{}settings} \PYG{n}{WHERE} \PYG{n}{context} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{postmaster}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}

\end{itemize}


\subsection{10.5 Narzędzia pomocnicze}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:narzedzia-pomocnicze}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pg\_ctl} – narzędzie do zarządzania serwerem (start/stop/reload).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{psql} – klient terminalowy PostgreSQL do wykonywania zapytań oraz operacji administracyjnych.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pgAdmin} – graficzne narzędzie do zarządzania bazą PostgreSQL (umożliwia edycję konfiguracji przez GUI).

\end{itemize}


\subsection{10.6 Kontrola dostępu i mechanizmy uwierzytelniania}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:kontrola-dostepu-i-mechanizmy-uwierzytelniania}}
\sphinxAtStartPar
Konfiguracja umożliwia określenie, z jakich adresów i w jaki sposób można łączyć się z bazą:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dostęp lokalny (localhost)} – połączenia z tej samej maszyny.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dostęp z podsieci} – administrator może wskazać konkretne podsieci IP (np. \sphinxcode{\sphinxupquote{192.168.0.0/24}}).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Mechanizmy uwierzytelniania} – np. \sphinxcode{\sphinxupquote{md5}}, \sphinxcode{\sphinxupquote{scram\sphinxhyphen{}sha\sphinxhyphen{}256}}, \sphinxcode{\sphinxupquote{peer}} (weryfikacja użytkownika systemowego) czy \sphinxcode{\sphinxupquote{trust}}.

\end{itemize}

\sphinxAtStartPar
Ważne, aby mechanizm \sphinxcode{\sphinxupquote{peer}} był odpowiednio skonfigurowany, gdyż umożliwia automatyczną autoryzację, jeśli nazwa użytkownika systemowego i bazy zgadza się.


\section{11. Planowanie}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:planowanie}}
\sphinxAtStartPar
Planowanie w kontekście PostgreSQL oznacza optymalizację wykonania zapytań oraz efektywne zarządzanie zasobami.


\subsection{11.1 Co to jest planowanie zapytań?}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:co-to-jest-planowanie-zapytan}}
\sphinxAtStartPar
Proces planowania zapytań obejmuje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Analizę składni i struktury zapytania SQL.

\item {} 
\sphinxAtStartPar
Przegląd dostępnych statystyk dotyczących tabel, indeksów i danych.

\item {} 
\sphinxAtStartPar
Dobór sposobu dostępu do danych (pełny skan, indeks, join, sortowanie).

\item {} 
\sphinxAtStartPar
Tworzenie planu wykonania, czyli sekwencji operacji potrzebnych do uzyskania wyniku.

\end{itemize}

\sphinxAtStartPar
Administrator może również kontrolować częstotliwość aktualizacji statystyk (np. \sphinxcode{\sphinxupquote{default\_statistics\_target}}, \sphinxcode{\sphinxupquote{autovacuum}}).


\subsection{11.2 Mechanizm planowania w PostgreSQL}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:mechanizm-planowania-w-postgresql}}
\sphinxAtStartPar
PostgreSQL wykorzystuje kosztowy optymalizator; przy użyciu statystyk (liczby wierszy, rozkładu danych) szacuje „koszt” różnych metod wykonania zapytania, wybierając tę, która jest najtańsza pod względem czasu i zasobów.


\subsection{11.3 Statystyki i ich aktualizacja}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:statystyki-i-ich-aktualizacja}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Statystyki są tworzone przy pomocy polecenia \sphinxcode{\sphinxupquote{ANALYZE}} – zbiera dane o rozkładzie wartości kolumn.

\item {} 
\sphinxAtStartPar
Mechanizm autovacuum odświeża statystyki automatycznie.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Przykład:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ANALYZE} \PYG{p}{[}\PYG{n}{nazwa\PYGZus{}tabeli}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
W systemach o dużym obciążeniu planowanie uwzględnia również równoległość (parallel query).


\subsection{11.4 Typy planów wykonania}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:typy-planow-wykonania}}
\sphinxAtStartPar
Przykładowe typy planów wykonania:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Seq Scan} – pełny skan tabeli (gdy indeksy są niedostępne lub nieefektywne).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Index Scan} – wykorzystanie indeksu.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bitmap Index Scan} – łączenie efektywności indeksów ze skanem sekwencyjnym.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Nested Loop Join} – efektywny join dla małych zbiorów.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Hash Join} – buduje tablicę hash dla dużych zbiorów.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Merge Join} – stosowany, gdy dane są posortowane.

\end{itemize}


\subsection{11.5 Jak sprawdzić plan zapytania?}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:jak-sprawdzic-plan-zapytania}}
\sphinxAtStartPar
Aby zobaczyć plan wybrany przez PostgreSQL, można użyć:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{EXPLAIN} \PYG{n}{ANALYZE} \PYG{n}{SELECT} \PYG{o}{*} \PYG{n}{FROM} \PYG{n}{tabela} \PYG{n}{WHERE} \PYG{n}{kolumna} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wartość}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{EXPLAIN}} – wyświetla plan bez wykonania zapytania.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ANALYZE}} – wykonuje zapytanie i podaje rzeczywiste czasy wykonania.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Przykładowy wynik:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Index} \PYG{n}{Scan} \PYG{n}{using} \PYG{n}{idx\PYGZus{}kolumna} \PYG{n}{on} \PYG{n}{tabela} \PYG{p}{(}\PYG{n}{cost}\PYG{o}{=}\PYG{l+m+mf}{0.29}\PYG{o}{.}\PYG{l+m+mf}{.8}\PYG{l+m+mf}{.56} \PYG{n}{rows}\PYG{o}{=}\PYG{l+m+mi}{3} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{244}\PYG{p}{)}
\PYG{n}{Index} \PYG{n}{Cond}\PYG{p}{:} \PYG{p}{(}\PYG{n}{kolumna} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wartość}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{text}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{11.6 Parametry planowania i optymalizacji}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:parametry-planowania-i-optymalizacji}}
\sphinxAtStartPar
W pliku \sphinxcode{\sphinxupquote{postgresql.conf}} można konfigurować m.in.:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{random\_page\_cost}} – koszt odczytu strony z dysku SSD/HDD.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cpu\_tuple\_cost}} – koszt przetwarzania pojedynczego wiersza.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{enable\_seqscan}}, \sphinxcode{\sphinxupquote{enable\_indexscan}}, \sphinxcode{\sphinxupquote{enable\_bitmapscan}} – włączanie/wyłączanie konkretnych typów skanów.

\end{itemize}

\sphinxAtStartPar
Dostosowanie tych parametrów pozwala zoptymalizować planowanie zgodnie ze specyfiką sprzętu i obciążenia.


\section{12. Tabele – rozmiar, planowanie i monitorowanie}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:tabele-rozmiar-planowanie-i-monitorowanie}}

\subsection{12.1 Rozmiar tabeli}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:rozmiar-tabeli}}
\sphinxAtStartPar
Rozmiar tabeli w PostgreSQL obejmuje dane (wiersze), strukturę, indeksy, dane TOAST oraz pliki statystyk. Do monitorowania rozmiaru stosuje się funkcje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_relation\_size()}} – rozmiar tabeli lub pojedynczego indeksu.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_total\_relation\_size()}} – całkowity rozmiar tabeli wraz z indeksami i TOAST.

\end{itemize}


\subsection{12.2 Planowanie rozmiaru i jego kontrola}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:planowanie-rozmiaru-i-jego-kontrola}}
\sphinxAtStartPar
Podczas projektowania bazy danych należy oszacować potencjalny rozmiar tabel, biorąc pod uwagę liczbę wierszy i rozmiar pojedynczego rekordu. PostgreSQL nie posiada sztywnego limitu (poza ograniczeniami systemu plików i 32\sphinxhyphen{}bitowym limitem liczby stron). Parametr \sphinxcode{\sphinxupquote{fillfactor}} może być stosowany do optymalizacji częstotliwości operacji UPDATE i VACUUM.


\subsection{12.3 Monitorowanie rozmiaru tabel}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:monitorowanie-rozmiaru-tabel}}
\sphinxAtStartPar
\sphinxstylestrong{Przykład zapytania:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SELECT} \PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nazwa\PYGZus{}tabeli}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Inne funkcje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_relation\_size}} – rozmiar samej tabeli.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_indexes\_size}} – rozmiar indeksów.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_table\_size}} – zwraca łączny rozmiar tabeli wraz z TOAST.

\end{itemize}


\subsection{12.4 Planowanie na poziomie tabel}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:planowanie-na-poziomie-tabel}}
\sphinxAtStartPar
Administrator może wpływać na fizyczne rozmieszczenie danych poprzez:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Tablespaces} – przenoszenie tabel lub indeksów na inne dyski/partycje.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Podział tabel (partitioning)} – rozbijanie dużych tabel na mniejsze części.

\end{itemize}


\subsection{12.5 Monitorowanie stanu tabel}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:monitorowanie-stanu-tabel}}
\sphinxAtStartPar
Monitorowanie obejmuje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Śledzenie fragmentacji danych.

\item {} 
\sphinxAtStartPar
Kontrolę wzrostu tabel i indeksów.

\item {} 
\sphinxAtStartPar
Statystyki dotyczące operacji odczytów i zapisów.

\end{itemize}

\sphinxAtStartPar
Narzędzia i widoki systemowe:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_stat\_all\_tables}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_stat\_user\_tables}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_stat\_activity}}

\end{itemize}


\subsection{12.6 Konserwacja i optymalizacja tabel}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:konserwacja-i-optymalizacja-tabel}}
\sphinxAtStartPar
Regularne uruchamianie poleceń:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{VACUUM} – usuwa martwe wiersze, zapobiegając nadmiernej fragmentacji.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ANALYZE} – aktualizuje statystyki, ułatwiając optymalizację zapytań.

\end{itemize}

\sphinxAtStartPar
Dla bardzo dużych tabel można stosować \sphinxcode{\sphinxupquote{VACUUM FULL}} lub reorganizację danych, aby odzyskać przestrzeń.


\section{13. Rozmiar pojedynczych tabel, rozmiar wszystkich tabel, indeksów tabeli}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:rozmiar-pojedynczych-tabel-rozmiar-wszystkich-tabel-indeksow-tabeli}}
\sphinxAtStartPar
Efektywne zarządzanie rozmiarem tabel oraz ich indeksów ma kluczowe znaczenie dla wydajności systemu.


\subsection{13.1 Rozmiar pojedynczej tabeli}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:rozmiar-pojedynczej-tabeli}}
\sphinxAtStartPar
Do pozyskania informacji o rozmiarze konkretnej tabeli służą funkcje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_relation\_size('nazwa\_tabeli')}} – rozmiar danych tabeli (w bajtach).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_table\_size('nazwa\_tabeli')}} – rozmiar danych tabeli wraz z danymi TOAST.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pg\_total\_relation\_size('nazwa\_tabeli')}} – całkowity rozmiar tabeli wraz z indeksami i TOAST.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Przykład zapytania:}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SELECT}
  \PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nazwa\PYGZus{}tabeli}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{n}{AS} \PYG{n}{data\PYGZus{}size}\PYG{p}{,}
  \PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}indexes\PYGZus{}size}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nazwa\PYGZus{}tabeli}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{n}{AS} \PYG{n}{indexes\PYGZus{}size}\PYG{p}{,}
  \PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nazwa\PYGZus{}tabeli}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)} \PYG{n}{AS} \PYG{n}{total\PYGZus{}size}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{13.2 Rozmiar wszystkich tabel w bazie}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:rozmiar-wszystkich-tabel-w-bazie}}
\sphinxAtStartPar
Zapytanie pozwalające wylistować wszystkie tabele i ich rozmiary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SELECT}
  \PYG{n}{schemaname}\PYG{p}{,}
  \PYG{n}{relname} \PYG{n}{AS} \PYG{n}{table\PYGZus{}name}\PYG{p}{,}
  \PYG{n}{pg\PYGZus{}size\PYGZus{}pretty}\PYG{p}{(}\PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{n}{relid}\PYG{p}{)}\PYG{p}{)} \PYG{n}{AS} \PYG{n}{total\PYGZus{}size}
\PYG{n}{FROM}
  \PYG{n}{pg\PYGZus{}catalog}\PYG{o}{.}\PYG{n}{pg\PYGZus{}statio\PYGZus{}user\PYGZus{}tables}
\PYG{n}{ORDER} \PYG{n}{BY}
  \PYG{n}{pg\PYGZus{}total\PYGZus{}relation\PYGZus{}size}\PYG{p}{(}\PYG{n}{relid}\PYG{p}{)} \PYG{n}{DESC}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{13.3 Rozmiar indeksów tabeli}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:rozmiar-indeksow-tabeli}}
\sphinxAtStartPar
Funkcja:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}indexes\PYGZus{}size}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nazwa\PYGZus{}tabeli}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Pozwala sprawdzić rozmiar wszystkich indeksów przypisanych do danej tabeli. Monitorowanie indeksów pomaga w podejmowaniu decyzji o ich przebudowie lub usunięciu.


\subsection{13.4 Znaczenie rozmiarów}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:znaczenie-rozmiarow}}
\sphinxAtStartPar
Duże tabele i indeksy mogą powodować:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Wolniejsze operacje zapisu i odczytu.

\item {} 
\sphinxAtStartPar
Wydłużony czas tworzenia kopii zapasowych.

\item {} 
\sphinxAtStartPar
Większe wymagania przestrzeni dyskowej.

\end{itemize}

\sphinxAtStartPar
Regularne monitorowanie rozmiaru umożliwia planowanie działań optymalizacyjnych i konserwacyjnych.


\section{14. Rozmiar}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:rozmiar}}
\sphinxAtStartPar
Pojęcie „rozmiar” odnosi się do przestrzeni dyskowej zajmowanej przez elementy bazy danych – tabele, indeksy, pliki TOAST, a także całe bazy danych lub schematy.


\subsection{14.1 Rodzaje rozmiarów w PostgreSQL}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:rodzaje-rozmiarow-w-postgresql}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rozmiar pojedynczego obiektu} (tabeli, indeksu):
Funkcje takie jak \sphinxcode{\sphinxupquote{pg\_relation\_size()}}, \sphinxcode{\sphinxupquote{pg\_table\_size()}}, \sphinxcode{\sphinxupquote{pg\_indexes\_size()}} oraz \sphinxcode{\sphinxupquote{pg\_total\_relation\_size()}}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rozmiar schematu lub bazy danych}:
Funkcje \sphinxcode{\sphinxupquote{pg\_namespace\_size('nazwa\_schematu')}} oraz \sphinxcode{\sphinxupquote{pg\_database\_size('nazwa\_bazy')}}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rozmiar plików TOAST}:
Duże wartości (np. teksty, obrazy) są przenoszone do struktur TOAST, których rozmiar wliczany jest do rozmiaru tabeli, choć można go analizować osobno.

\end{itemize}


\subsection{14.2 Monitorowanie i kontrola rozmiaru}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:monitorowanie-i-kontrola-rozmiaru}}
\sphinxAtStartPar
Administratorzy baz danych powinni regularnie monitorować rozmiar baz danych i jej obiektów, aby:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Zapobiegać przekroczeniu limitów przestrzeni dyskowej.

\item {} 
\sphinxAtStartPar
Wcześniej wykrywać problemy z fragmentacją.

\item {} 
\sphinxAtStartPar
Planować archiwizację lub czyszczenie danych.

\end{itemize}

\sphinxAtStartPar
Do monitoringu można wykorzystać zapytania SQL lub narzędzia zewnętrzne (np. pgAdmin, pgBadger).


\subsection{14.3 Optymalizacja rozmiaru}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:optymalizacja-rozmiaru}}
\sphinxAtStartPar
Działania optymalizacyjne obejmują:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Reorganizację i VACUUM}: odzyskiwanie przestrzeni po usuniętych lub zaktualizowanych rekordach oraz poprawa statystyk.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Partycjonowanie tabel}: dzielenie dużych tabel na mniejsze, co ułatwia zarządzanie.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ograniczenia i typy danych}: odpowiedni dobór typów danych (np. \sphinxcode{\sphinxupquote{varchar(n)}} zamiast \sphinxcode{\sphinxupquote{text}}) oraz stosowanie ograniczeń (np. CHECK) zmniejsza rozmiar danych.

\end{itemize}


\subsection{14.4 Znaczenie zarządzania rozmiarem}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:znaczenie-zarzadzania-rozmiarem}}
\sphinxAtStartPar
Niewłaściwe zarządzanie przestrzenią dyskową może prowadzić do:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Spowolnienia działania bazy.

\item {} 
\sphinxAtStartPar
Problemów z backupem i odtwarzaniem.

\item {} 
\sphinxAtStartPar
Wzrostu kosztów utrzymania infrastruktury.

\end{itemize}


\section{Podsumowanie}
\label{\detokenize{Konfiguracja_baz_danych/Konfiguracja_baz_danych:podsumowanie}}
\sphinxAtStartPar
Zarządzanie konfiguracją bazy danych PostgreSQL, optymalizacja zapytań oraz monitorowanie i konserwacja tabel stanowią fundament skutecznego zarządzania systemem bazodanowym. Prawidłowe podejście do tych elementów zapewnia wysoką wydajność, niezawodność i skalowalność systemu.

\sphinxAtStartPar
—

\sphinxstepscope


\chapter{Bezpieczeństwo}
\label{\detokenize{Bezpieczenstwo/index:bezpieczenstwo}}\label{\detokenize{Bezpieczenstwo/index::doc}}\begin{quote}\begin{description}
\sphinxlineitem{Autorzy}\begin{itemize}
\item {} 
\sphinxAtStartPar
Katarzyna Tarasek

\item {} 
\sphinxAtStartPar
Błażej Uliasz

\end{itemize}

\end{description}\end{quote}


\section{1. pg\_hba.conf — opis pliku konfiguracyjnego PostgreSQL}
\label{\detokenize{Bezpieczenstwo/index:pg-hba-conf-opis-pliku-konfiguracyjnego-postgresql}}
\sphinxAtStartPar
Plik \sphinxcode{\sphinxupquote{pg\_hba.conf}} (skrót od \sphinxstyleemphasis{PostgreSQL Host\sphinxhyphen{}Based Authentication}) kontroluje, kto może się połączyć z bazą danych PostgreSQL, skąd, i w jaki sposób ma zostać uwierzytelniony.


\subsection{Format pliku}
\label{\detokenize{Bezpieczenstwo/index:format-pliku}}
\sphinxAtStartPar
Każdy wiersz odpowiada jednej regule dostępu:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{typ}\PYG{o}{\PYGZgt{}}  \PYG{o}{\PYGZlt{}}\PYG{n}{baza} \PYG{n}{danych}\PYG{o}{\PYGZgt{}}  \PYG{o}{\PYGZlt{}}\PYG{n}{użytkownik}\PYG{o}{\PYGZgt{}}  \PYG{o}{\PYGZlt{}}\PYG{n}{adres}\PYG{o}{\PYGZgt{}}  \PYG{o}{\PYGZlt{}}\PYG{n}{metoda}\PYG{o}{\PYGZgt{}}  \PYG{p}{[}\PYG{n}{opcje}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Opis elementów:


\subsection{Znaczenie Elementów}
\label{\detokenize{Bezpieczenstwo/index:znaczenie-elementow}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<typ>}} — Typ połączenia – np. \sphinxcode{\sphinxupquote{local}}, \sphinxcode{\sphinxupquote{host}}, \sphinxcode{\sphinxupquote{hostssl}}, \sphinxcode{\sphinxupquote{hostnossl}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<baza>}} — Nazwa bazy danych, do której ma być dostęp – konkretna lub \sphinxcode{\sphinxupquote{all}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<użytkownik>}} — Nazwa użytkownika PostgreSQL lub \sphinxcode{\sphinxupquote{all}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<adres>}} — Adres IP lub zakres CIDR klienta (np. \sphinxcode{\sphinxupquote{192.168.1.0/24}}); pomijany dla \sphinxcode{\sphinxupquote{local}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{<metoda>}} — Metoda uwierzytelnienia – np. \sphinxcode{\sphinxupquote{md5}}, \sphinxcode{\sphinxupquote{trust}}, \sphinxcode{\sphinxupquote{scram\sphinxhyphen{}sha\sphinxhyphen{}256}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{{[}opcje{]}}} — Opcjonalne dodatkowe parametry (np. \sphinxcode{\sphinxupquote{clientcert=1}})

\end{itemize}


\subsection{Typy połączeń}
\label{\detokenize{Bezpieczenstwo/index:typy-polaczen}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{local}} — Umożliwia połączenia \sphinxstylestrong{lokalne przez Unix socket} (pliki specjalne w systemie plików, np. \sphinxcode{\sphinxupquote{/var/run/postgresql/.s.PGSQL.5432}}).
Ten tryb jest dostępny \sphinxstylestrong{tylko na systemach Unix/Linux} i ignoruje pole \sphinxcode{\sphinxupquote{<adres>}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{host}} — Oznacza połączenia \sphinxstylestrong{przez TCP/IP}, niezależnie od tego, czy klient znajduje się na tym samym hoście, czy w sieci.
Wymaga podania adresu IP lub zakresu IP (w polu \sphinxcode{\sphinxupquote{<adres>}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hostssl}} — Jak \sphinxcode{\sphinxupquote{host}}, ale \sphinxstylestrong{wymusza użycie SSL/TLS}. Połączenia bez szyfrowania będą odrzucone.
Wymaga, aby serwer PostgreSQL był poprawnie skonfigurowany do obsługi SSL (np. pliki \sphinxcode{\sphinxupquote{server.crt}}, \sphinxcode{\sphinxupquote{server.key}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{hostnossl}} — Jak \sphinxcode{\sphinxupquote{host}}, ale \sphinxstylestrong{odrzuca połączenia przez SSL/TLS}. Działa tylko dla połączeń nieszyfrowanych.
Może być używane do rozróżnienia reguł dla klientów z/do SSL i bez SSL.

\end{itemize}


\subsection{Metody uwierzytelniania}
\label{\detokenize{Bezpieczenstwo/index:metody-uwierzytelniania}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{trust}} — brak uwierzytelnienia (niezalecane!)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{md5}} — Klient musi podać hasło, które jest przesyłane jako skrót MD5.
To popularna metoda w starszych wersjach PostgreSQL, ale obecnie uznawana za przestarzałą (choć nadal obsługiwana).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{scram\sphinxhyphen{}sha\sphinxhyphen{}256}} — Nowoczesna, bezpieczna metoda uwierzytelniania oparta na protokole SCRAM i algorytmie SHA\sphinxhyphen{}256.
Zalecana w produkcji od PostgreSQL 10 wzwyż. Wymaga, aby hasła w systemie były zapisane jako SCRAM, a nie MD5.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{peer}} — Tylko dla połączeń \sphinxcode{\sphinxupquote{local}}. Sprawdza, czy nazwa użytkownika systemowego (OS) pasuje do użytkownika PostgreSQL.
Stosowane w systemach Unix/Linux.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ident}} — Tylko dla połączeń TCP/IP. Wymaga usługi ident (lub pliku mapowania ident), aby ustalić, kto próbuje się połączyć.
Bardziej złożona i rzadziej używana niż \sphinxcode{\sphinxupquote{peer}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{reject}} — Zawsze odrzuca połączenie. Może być użyte do celowego blokowania określonych adresów lub użytkowników.

\end{itemize}


\subsection{Przykładowy wpis}
\label{\detokenize{Bezpieczenstwo/index:przykladowy-wpis}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} 1. Lokalny dostęp bez hasła}
\PYG{n}{local}   \PYG{n+nb}{all}             \PYG{n}{postgres}                                \PYG{n}{peer}
\end{sphinxVerbatim}


\subsection{Zmiany i przeładowanie}
\label{\detokenize{Bezpieczenstwo/index:zmiany-i-przeladowanie}}
\sphinxAtStartPar
Po zmianach w pliku należy przeładować konfigurację PostgreSQL:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pg\PYGZus{}ctl} \PYG{n}{reload}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{lub}\PYG{p}{:}
\PYG{n}{SELECT} \PYG{n}{pg\PYGZus{}reload\PYGZus{}conf}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{2. Uprawnienia użytkownika}
\label{\detokenize{Bezpieczenstwo/index:uprawnienia-uzytkownika}}
\sphinxAtStartPar
PostgreSQL pozwala na bardzo precyzyjne zarządzanie uprawnieniami użytkowników lub roli poprzez wiele poziomów dostępu — od globalnych uprawnień systemowych, przez bazy danych, aż po pojedyncze kolumny w tabelach.


\subsection{Poziom systemowy}
\label{\detokenize{Bezpieczenstwo/index:poziom-systemowy}}
\sphinxAtStartPar
To najwyższy poziom uprawnień, nadawany roli jako atrybut. Dotyczy całego klastra PostgreSQL:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{SUPERUSER} — Pełna kontrola nad serwerem, obejmuje wszystkie uprawnienia

\item {} 
\sphinxAtStartPar
\sphinxtitleref{CREATEDB} — Możliwość tworzenia nowych baz danych

\item {} 
\sphinxAtStartPar
\sphinxtitleref{CREATEROLE} — Tworzenie i zarządzanie rolami/użytkownikami

\item {} 
\sphinxAtStartPar
\sphinxtitleref{REPLICATION} — Umożliwia replikację danych (logiczna/strumieniowa)

\item {} 
\sphinxAtStartPar
\sphinxtitleref{BYPASSRLS} — Omija polityki RLS (Row\sphinxhyphen{}Level Security)

\end{itemize}


\subsection{Poziom bazy danych}
\label{\detokenize{Bezpieczenstwo/index:poziom-bazy-danych}}
\sphinxAtStartPar
Uprawnienia do konkretnej bazy danych:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{CONNECT} — Pozwala na połączenie z bazą danych

\item {} 
\sphinxAtStartPar
\sphinxtitleref{CREATE} — Pozwala na tworzenie schematów w tej bazie

\item {} 
\sphinxAtStartPar
\sphinxtitleref{TEMP} — Możliwość tworzenia tymczasowych tabel

\end{itemize}


\subsection{Poziom schematu}
\label{\detokenize{Bezpieczenstwo/index:poziom-schematu}}
\sphinxAtStartPar
Schemat (np. \sphinxtitleref{public}) to kontener na tabele, funkcje, typy. Uprawnienia:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{USAGE} — Umożliwia dostęp do schematu (bez tego SELECT/INSERT nie zadziała)

\item {} 
\sphinxAtStartPar
\sphinxtitleref{CREATE} — Pozwala tworzyć obiekty (np. tabele) w schemacie

\end{itemize}


\subsection{Poziom tabeli}
\label{\detokenize{Bezpieczenstwo/index:poziom-tabeli}}
\sphinxAtStartPar
Uprawnienia do całej tabeli :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{SELECT} — Odczyt danych

\item {} 
\sphinxAtStartPar
\sphinxtitleref{INSERT} — Wstawianie danych

\item {} 
\sphinxAtStartPar
\sphinxtitleref{UPDATE} — Modyfikacja danych

\item {} 
\sphinxAtStartPar
\sphinxtitleref{DELETE} — Usuwanie danych

\end{itemize}


\subsection{Przykład}
\label{\detokenize{Bezpieczenstwo/index:przyklad}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GRANT} \PYG{n}{SELECT}\PYG{p}{,} \PYG{n}{UPDATE} \PYG{n}{ON} \PYG{n}{employees} \PYG{n}{TO} \PYG{n}{hr\PYGZus{}team}\PYG{p}{;}
\PYG{n}{REVOKE} \PYG{n}{DELETE} \PYG{n}{ON} \PYG{n}{employees} \PYG{n}{FROM} \PYG{n}{kontraktorzy}\PYG{p}{;}
\end{sphinxVerbatim}


\section{3. Zarządzanie użytkownikami a dane wprowadzone}
\label{\detokenize{Bezpieczenstwo/index:zarzadzanie-uzytkownikami-a-dane-wprowadzone}}
\sphinxAtStartPar
Zarządzanie użytkownikami w PostgreSQL dotyczy tworzenia, usuwania i modyfikowania użytkowników. Sytuacja na którą trzeba tutaj zwrócić uwagę jest usuwanie użytkonika ale pozostawienie danych, które wprowadził.


\subsection{Tworzenie i modyfikacja użytkowników}
\label{\detokenize{Bezpieczenstwo/index:tworzenie-i-modyfikacja-uzytkownikow}}
\sphinxAtStartPar
Do tworzenia nowych użytkowników używamy polecenia \sphinxcode{\sphinxupquote{CREATE USER}}. Do modyfikowania użytkowników, którzy już istnieją, używamy polecenia \sphinxcode{\sphinxupquote{ALETER USER}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CREATE} \PYG{n}{USER} \PYG{n}{username} \PYG{n}{WITH} \PYG{n}{PASSWORD} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{password}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{ALTER} \PYG{n}{USER} \PYG{n}{username} \PYG{n}{WITH} \PYG{n}{PASSWORD} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{new\PYGZus{}password}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Usuwanie użytkowników}
\label{\detokenize{Bezpieczenstwo/index:usuwanie-uzytkownikow}}
\sphinxAtStartPar
Do usuwania użytkowników, używamy polecenia {\color{red}\bfseries{}``}DROP USER`:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DROP} \PYG{n}{USER} \PYG{n}{username}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Dane wprowadzone przez uśytkownika np. za pomocą polecenia \sphinxcode{\sphinxupquote{INSERT}} pozostają, nawet jeśli jego konto zostało usunięte.


\subsection{Usunięcie użytkownika, a dane które posiadał}
\label{\detokenize{Bezpieczenstwo/index:usuniecie-uzytkownika-a-dane-ktore-posiadal}}
\sphinxAtStartPar
Po usunięciu używtkonika dane, które posiadał nie są automatycznie usuwane. Dane te pozostają w bazie danych ale stają się „niedostępne” dla tego użytkownika. Aby się ich pozbyć, musi to zrobić użytkownik który ma do nich uprawnienia, korzystając z plecenia \sphinxcode{\sphinxupquote{DROP}}.


\subsection{Usunięcie użytkowników, a obietky}
\label{\detokenize{Bezpieczenstwo/index:usuniecie-uzytkownikow-a-obietky}}
\sphinxAtStartPar
Usuniecie użytkownika, który jest właścicielem obiektów, wygląda inaczej niż przy wcześniejszych danych. Jeżeli użytkownik jest właścicielem jakiegoś obiektu, to jego usunięcie skutkuje błędem:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ERROR}\PYG{p}{:} \PYG{n}{role} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{username}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{cannot} \PYG{n}{be} \PYG{n}{droped} \PYG{n}{becouse} \PYG{n}{some} \PYG{n}{objects} \PYG{n}{depend} \PYG{n}{on} \PYG{n}{it}
\end{sphinxVerbatim}

\sphinxAtStartPar
Aby zapobiec takim błędom stosujemy poniższe rozwiazanie:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{REASSIGN} \PYG{n}{OWNED} \PYG{n}{BY} \PYG{n}{username} \PYG{n}{TO} \PYG{n}{nowa\PYGZus{}rola}\PYG{p}{;}
\PYG{n}{DROP} \PYG{n}{OWNER} \PYG{n}{BY} \PYG{n}{username}\PYG{p}{;}
\PYG{n}{DROP} \PYG{n}{ROLE} \PYG{n}{username}\PYG{p}{;}
\end{sphinxVerbatim}


\section{4. Zabezpieczenie połączenia przez SSL/TLS}
\label{\detokenize{Bezpieczenstwo/index:zabezpieczenie-polaczenia-przez-ssl-tls}}
\sphinxAtStartPar
TLS (Transport Layer Security) i jego poprzednik SSL (Secure Sockets Layer) to kryptograficzne protokoły służące do zabezpieczania połączeń sieciowych. W PostgreSQL służą one do szyfrowania transmisji danych pomiędzy klientem a serwerem, uniemożliwiając podsłuch, modyfikację lub podszywanie się pod jedną ze stron.


\subsection{Konfiguracja SSL/TLS w PostgreSQL}
\label{\detokenize{Bezpieczenstwo/index:konfiguracja-ssl-tls-w-postgresql}}
\sphinxAtStartPar
Konfiguracja serwera: musimy edytować dwa pliki i zrestartować serwer PostgreSQL. Plik \sphinxcode{\sphinxupquote{postgresql.conf}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ssl} \PYG{o}{=} \PYG{n}{on}
\PYG{n}{ssl\PYGZus{}cert\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{server.crt}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ssl\PYGZus{}key\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{server.key}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ssl\PYGZus{}ca\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{root.crt}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ssl\PYGZus{}min\PYGZus{}protocol\PYGZus{}version} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TLSv1.3}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
oraz «»pg\_hba.conf»»:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hostssl} \PYG{n+nb}{all} \PYG{n+nb}{all} \PYG{l+m+mf}{0.0}\PYG{l+m+mf}{.0}\PYG{l+m+mf}{.0}\PYG{o}{/}\PYG{l+m+mi}{0} \PYG{n}{cert}
\end{sphinxVerbatim}

\sphinxAtStartPar
Generowanie certyfikatów: jeśli nie używamy komercyjnego CA, możemy sami go wygerenować, a pomocą poniższych komend:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{genrsa} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{l+m+mi}{2048}
\PYG{n}{openssl} \PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{new} \PYG{o}{\PYGZhy{}}\PYG{n}{key} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{csr}
\PYG{n}{openssl} \PYG{n}{x509} \PYG{o}{\PYGZhy{}}\PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{days} \PYG{l+m+mi}{365} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{server}\PYG{o}{.}\PYG{n}{csr} \PYG{o}{\PYGZhy{}}\PYG{n}{signkey} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{crt}
\end{sphinxVerbatim}

\sphinxAtStartPar
Konfiguracja klienta: parametry SSL, których możemy użyć.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sslmode}} \sphinxhyphen{} kontroluje wymuszanie i weryfikację SSL (\sphinxcode{\sphinxupquote{require}}, \sphinxcode{\sphinxupquote{verify\sphinxhyphen{}ca}}, \sphinxcode{\sphinxupquote{verify\sphinxhyphen{}full}})

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sslcert}} \sphinxhyphen{} ścieżka do certyfikatu klienta (jeśli wymagane uwierzytelnienie certyfikatem)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sslkey}} \sphinxhyphen{}  klucz prywatny klienta

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sslrootcert}} \sphinxhyphen{} certyfikat CA do weryfikacji certyfikatu serwera

\end{itemize}


\subsection{Monitorowanie i testowanie SSL/TLS}
\label{\detokenize{Bezpieczenstwo/index:monitorowanie-i-testowanie-ssl-tls}}
\sphinxAtStartPar
Sprawdzenie czy połączenie jest szyfrowanie w PostgreSQL wystarczy użyć prostego polecenia \sphinxcode{\sphinxupquote{SELECT ssl\_is\_used();}}. Jeśli jednak chcemy dostać więcej informacji, musimy wpisać poniższe polecenia:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SELECT} \PYG{n}{datname}\PYG{p}{,} \PYG{n}{usename}\PYG{p}{,} \PYG{n}{ssl}\PYG{p}{,} \PYG{n}{client\PYGZus{}addr}\PYG{p}{,} \PYG{n}{application\PYGZus{}name}\PYG{p}{,} \PYG{n}{backend\PYGZus{}type}
\PYG{n}{FROM} \PYG{n}{pg\PYGZus{}stat\PYGZus{}ssl}
\PYG{n}{JOIN} \PYG{n}{pg\PYGZus{}stat\PYGZus{}activity} \PYG{n}{ON} \PYG{n}{pg\PYGZus{}stat\PYGZus{}ssl}\PYG{o}{.}\PYG{n}{pid} \PYG{o}{=} \PYG{n}{pg\PYGZus{}stat\PYGZus{}activity}\PYG{o}{.}\PYG{n}{pid}
\PYG{n}{ORDER} \PYG{n}{BY} \PYG{n}{ssl}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Testowanie z poziomu terminala pozwala podejrzeć szczegóły TLS takie jak certyfikaty, wesję protokołu czy użyty szyft. Wpisujemy poniższą komendę:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{s\PYGZus{}client} \PYG{o}{\PYGZhy{}}\PYG{n}{starttls} \PYG{n}{postgres} \PYG{o}{\PYGZhy{}}\PYG{n}{connect} \PYG{n}{example}\PYG{o}{.}\PYG{n}{com}\PYG{p}{:}\PYG{l+m+mi}{5432} \PYG{o}{\PYGZhy{}}\PYG{n}{showcerts}
\end{sphinxVerbatim}


\section{5. Szyfrowanie danych}
\label{\detokenize{Bezpieczenstwo/index:szyfrowanie-danych}}
\sphinxAtStartPar
Szyfrowanie danych w PostgreSQL odgrywa kluczową rolę w zapewnianiu poufności, integralności i ochrony danych przed nieautoryzowanym dostępem. Można je realizować na różnych poziomach: transmisji (in\sphinxhyphen{}transit), przechowywania (at\sphinxhyphen{}rest) oraz aplikacyjnym.


\subsection{Szyfrowanie transmisji}
\label{\detokenize{Bezpieczenstwo/index:szyfrowanie-transmisji}}
\sphinxAtStartPar
Korzystając z technologi SSL/TLS chroni dane przesyłane pomiędzy klientem, a serwerem przed podsłuchiwaniem lub modyfikacją. Wymaga konfiguracji serwera PostgreSQL do obsługi SSL oraz klienci muszą łączyć się przez SSL.


\subsection{Szyfrowanie całego dysku}
\label{\detokenize{Bezpieczenstwo/index:szyfrowanie-calego-dysku}}
\sphinxAtStartPar
Dane są szyfrowane na poziomie systemu operacyjnego lub warstwy przechowywania. Stosowanymi roziazaniami jest LUKS, BitLocker, szyfrowanie oferowane przez chmury. Zaletami tego szyfrowania jest transparentność dla PostgrSQL i łatwość w implementacji. Wadami za to jest brak selektywnego szyfrowania oraz fakt, że jeśli system jest aktywny to dane są odszyfrowane i dostępne.


\subsection{Szyfrowanie na poziomie kolumn z użyciem pgcrypto}
\label{\detokenize{Bezpieczenstwo/index:szyfrowanie-na-poziomie-kolumn-z-uzyciem-pgcrypto}}
\sphinxAtStartPar
Pozwala na szyfrowanie konkretnych kolumn danych. Rozszerzenie to \sphinxcode{\sphinxupquote{pgcrypto}}. Funkcje takiego szyfrowania to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
symetryczne szyfrowanie

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SELECT} \PYG{n}{pgp\PYGZus{}sym\PYGZus{}encrypt}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tajne dane}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{haslo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{SELECT} \PYG{n}{pgp\PYGZus{}sym\PYGZus{}decrypt}\PYG{p}{(}\PYG{n}{kolumna}\PYG{p}{:}\PYG{p}{:}\PYG{n}{bytea}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{haslo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
asymetryczne szyfrowanie (z uśyciem kluczy publicznych/prywatnych)

\item {} 
\sphinxAtStartPar
haszowanie

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SELECT} \PYG{n}{digest}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{haslo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sha256}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Zaletami tego szyfrowania jest duża elastyczność i selektywne szyfrowanie. Wadami zaś wydajność i konieczność zarządzania kluczami w aplikacji.


\subsection{Szyfrowanie na poziomie aplikacji}
\label{\detokenize{Bezpieczenstwo/index:szyfrowanie-na-poziomie-aplikacji}}
\sphinxAtStartPar
Dane są szyfrowane przed zapisaniem do bazy danych i odszyfrowywane po odczycie. Używane biblioteki:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Python – cryptography, pycryptodome,

\item {} 
\sphinxAtStartPar
Java – javax.crypto, Bouncy Castle,

\item {} 
\sphinxAtStartPar
JavaScript – crypto, sjcl.

\end{itemize}

\sphinxAtStartPar
Zaletami jest pełna kontrola nad szyfrowaniem oraz fakt, że dane są chronione nawet w razie włamania do bazy. Wadami zaś trudniejsze wyszukiwanie i indeksowanie, konieczność przeniesienia odpowiedzialności za bezpieczeństwo do aplikacji oraz problemy ze zgodnością przy migracjach danych.


\subsection{Zarządzanie kluczami szyfrującymi}
\label{\detokenize{Bezpieczenstwo/index:zarzadzanie-kluczami-szyfrujacymi}}
\sphinxAtStartPar
Niezależnie od rodzaju szyfrowania, bezpieczne zarządzanie kluczami jest kluczowe dla ochrony danych. Klucze powinny być generowane, przechowywane, dystrybuowane i niszczone w sposób bezpieczny. Potrzebne są do tego odpowiednie narzędzia. Rekomendowanymi narzędziami do bezpiecznego zarządzania kluczami są:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Sprzętowe moduły bezpieczeństwa (HSM) \sphinxhyphen{} Urządzenia te oferują bezpieczne środowisko do generowania, przechowywania i zarządzania kluczami. HSM\sphinxhyphen{}y są odporne na fizyczne ataki i zapewniają wysoki poziom bezpieczeństwa.

\item {} 
\sphinxAtStartPar
Systemy zarządzania kluczami (KMS) \sphinxhyphen{} KMS to oprogramowanie, które centralizuje zarządzanie kluczami, umożliwiając ich bezpieczne przechowywanie, rotację i dystrybucję.

\item {} 
\sphinxAtStartPar
Narzędzia do bezpiecznej komunikacji \sphinxhyphen{} Narzędzia takie jak Signal czy WhatsApp oferują szyfrowanie end\sphinxhyphen{}to\sphinxhyphen{}end, które chroni komunikację przed nieautoryzowanym dostępem.

\item {} 
\sphinxAtStartPar
Narzędzia do szyfrowania dysków \sphinxhyphen{} Takie jak BitLocker czy FileVault, które pozwalają na zaszyfrowanie całego dysku twardego lub jego partycji.

\end{itemize}

\sphinxstepscope


\chapter{Kontrola i konserwacja baz danych}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:kontrola-i-konserwacja-baz-danych}}\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja::doc}}

\section{Wprowadzenie}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:wprowadzenie}}
\sphinxAtStartPar
Autor: Bartłomiej Czyż

\sphinxAtStartPar
Systemy baz danych są niezwykle ważnym elementem infrastruktury informatycznej współczesnych organizacji. Umożliwiają przechowywanie, zarządzanie i analizę danych w sposób bezpieczny oraz wydajny. Aby zapewnić ich niezawodność, integralność i wysoką dostępność, konieczne jest prowadzenie regularnych działań z zakresu kontroli i konserwacji. Działania te można podzielić na część fizyczną oraz część programową, a sposób ich przeprowadzania różni się w zależności od rodzaju i architektury używanej bazy danych.


\section{Podział konserwacji baz danych}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:podzial-konserwacji-baz-danych}}
\sphinxAtStartPar
Autor: Bartłomiej Czyż


\subsection{Konserwacja fizyczna}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:konserwacja-fizyczna}}
\sphinxAtStartPar
Konserwacja fizyczna obejmuje wszystkie działania związane z infrastrukturą sprzętową i zasobami systemowymi, na których działa baza danych. Do najważniejszych elementów tej konserwacji należą:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Monitorowanie stanu dysków twardych – pozostała przestrzeń na dyskach, zużycie dysków oraz fragmentacja danych,

\item {} 
\sphinxAtStartPar
Zabezpieczenie fizyczne serwerów – kontrola dostępu, ochrona przeciwpożarowa, klimatyzacja,

\item {} 
\sphinxAtStartPar
Zasilanie awaryjne (UPS) \sphinxhyphen{} zabezpieczenie bazy przed skutkami nagłego zaniku zasilania,

\item {} 
\sphinxAtStartPar
Monitoring stanu sieci – wydajność i stabilność połączenia między bazą a klientami,

\item {} 
\sphinxAtStartPar
Tworzenie kopii zapasowych na nośnikach fizycznych – np. dyskach zewnętrznych czy taśmach LTO.

\end{itemize}


\subsection{Konserwacja programowa}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:konserwacja-programowa}}
\sphinxAtStartPar
Konserwacja programowa odnosi się do czynności wykonywanych na poziomie oprogramowania i logiki działania systemu bazy danych. Obejmuje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Zarządzanie użytkownikami i ich uprawnieniami,

\item {} 
\sphinxAtStartPar
Optymalizację zapytań SQL,

\item {} 
\sphinxAtStartPar
Aktualizację oprogramowania bazodanowego (np. MySQL, PostgreSQL),

\item {} 
\sphinxAtStartPar
Defragmentację indeksów,

\item {} 
\sphinxAtStartPar
Weryfikację integralności danych i naprawę uszkodzonych rekordów,

\item {} 
\sphinxAtStartPar
Automatyczne zadania konserwacyjne (cron, schedulery),

\item {} 
\sphinxAtStartPar
Reduplikację i redundancję \sphinxhyphen{} konfiguracja serwerów zapasowych.

\end{itemize}


\section{Różnice konserwacyjne w zależności od rodzaju bazy danych}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:roznice-konserwacyjne-w-zaleznosci-od-rodzaju-bazy-danych}}
\sphinxAtStartPar
Autor: Bartłomiej Czyż


\subsection{PostgreSQL}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:postgresql}}
\sphinxAtStartPar
PostgreSQL to zaawansowany system RDBMS, znany z silnego wsparcia dla różnych typów danych i transakcyjności.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Fizyczna konserwacja:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Złożona struktura katalogów danych (base, pg\_wal, pg\_tblspc) – wymaga regularnego monitoringu,

\item {} 
\sphinxAtStartPar
Możliwość wykorzystania narzędzia pg\_basebackup do tworzenia pełnych kopii fizycznych.

\end{itemize}

\item {} 
\sphinxAtStartPar
Programowa konserwacja:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Automatyczne zadania VACUUM, ANALYZE – zapewniają odzyskiwanie przestrzeni po usunięciu rekordów,

\item {} 
\sphinxAtStartPar
Możliwość używania pg\_repack do defragmentacji bez przestojów,

\item {} 
\sphinxAtStartPar
Silne wsparcie dla replikacji strumieniowej i klastrów wysokiej dostępności (HA).

\end{itemize}

\end{enumerate}


\subsection{MySQL}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:mysql}}
\sphinxAtStartPar
MySQL jest obecnie jedną z najpopularniejszych relacyjnych baz danych, szeroko stosowana w aplikacjach webowych.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Fizyczna konserwacja:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Wymaga monitorowania plików .ibd (w przypadku silknika InnoDB), które mogą znacznie rosnąć,

\item {} 
\sphinxAtStartPar
Backup danych realizowany poprzez mysqldump lub system replikacji binlogów.

\end{itemize}

\item {} 
\sphinxAtStartPar
Programowa konserwacja:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Regularne sprawdzanie indeksów (ANALYZE TABLE, OPTIMIZE TABLE),

\item {} 
\sphinxAtStartPar
Używanie narzędzi typu mysqlcheck do weryfikacji i naprawy tabel,

\item {} 
\sphinxAtStartPar
Konfiguracja pliku my.cnf w celu dostosowania do wymagań aplikacji.

\end{itemize}

\end{enumerate}


\subsection{SQLite (np. LightSQL)}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:sqlite-np-lightsql}}
\sphinxAtStartPar
SQLite, używana w aplikacjach mobilnych i desktopowych, różni się znacznie od serwerowych baz danych.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Fizyczna konserwacja:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Brak klasycznego serwera – baza to pojedynczy plik .db,

\item {} 
\sphinxAtStartPar
Konieczność regularnego kopiowania pliku bazy danych jako backup.

\end{itemize}

\item {} 
\sphinxAtStartPar
Programowa konserwacja:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Użycie polecenia VACUUM do defragmentacji i zmniejszenia rozmiaru pliku,

\item {} 
\sphinxAtStartPar
Ograniczone możliwości równoczesnego dostępu – wymaga uwagi w aplikacjach wielowątkowych,

\item {} 
\sphinxAtStartPar
Nie wymaga osobnych usług do zarządzania – działa bezpośrednio w aplikacji.

\end{itemize}

\end{enumerate}


\subsection{Microsoft SQL Server}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:microsoft-sql-server}}
\sphinxAtStartPar
System korporacyjny, szeroko wykorzystywany w dużych organizacjach.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Fizyczna konserwacja:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Obsługuje macierze RAID i pamięci masowe SAN,

\item {} 
\sphinxAtStartPar
Regularne kopie pełne, różnicowe i dzienniki transakcyjne.

\end{itemize}

\item {} 
\sphinxAtStartPar
Programowa konserwacja:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Zaawansowany SQL Server Agent – możliwość harmonogramowania zadań,

\item {} 
\sphinxAtStartPar
Narzędzia do monitorowania stanu instancji (SQL Profiler, Database Tuning Advisor),

\item {} 
\sphinxAtStartPar
Wsparcie dla Always On Availability Groups dla wysokiej dostępności.

\end{itemize}

\end{enumerate}


\section{Planowanie konserwacji bazy danych}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:planowanie-konserwacji-bazy-danych}}
\sphinxAtStartPar
Autor: Piotr Mikołajczyk

\sphinxAtStartPar
Konserwację bazy danych należy przeprowadzać regularnie, np. co tydzień lub co miesiąc. Nie powinna mieć miejsca w godzinach szczytu. Przeprowadzenie konserwacji może również okazać się koniecznie po wykryciu błędu lub wystąpieniu awarii.

\sphinxAtStartPar
Konserwacja może obejmować m.in. zmianę parametrów konfiguracji bazy, przeprowadzenie procesu VACUUM, zmianę uprawnien użytkowników, aktualizacje systemowe i wykonanie backupów lub przywrócenie danych.

\sphinxAtStartPar
Działanie te muszą zostać przeprowadzone w czasie, gdy mamy pewność, że żaden klient nie będzie podłączony, nie będą przeprowadzane żadne transakcje. Użytkownicy powinni być uprzednio poinformowani o czasie przeprowadzenia konserwacji. Mimo to, należy wcześniej sprawdzić, czy nie ma aktywnych sesji.


\section{Uruchamianie, zatrzymywanie i restartowanie serwera bazy danych}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:uruchamianie-zatrzymywanie-i-restartowanie-serwera-bazy-danych}}
\sphinxAtStartPar
Autor: Piotr Mikołajczyk

\sphinxAtStartPar
Działania, takie jak aktualizacja oprogramowania, instalacja rozszerzeń, wprowadzenie pewnych zmian w plikach konfiguracyjnych, migracja danych, wykonanie backupów bazy, wymagają zrestartowania, zatrzymania bądź ponownego uruchomienia serwera bazy danych.


\subsection{Uruchamianie}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:uruchamianie}}
\sphinxAtStartPar
Linux:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }start\PYG{+w}{ }postgresql
\end{sphinxVerbatim}

\sphinxAtStartPar
Windows CMD:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
net start postgresql\PYGZhy{}x64\PYGZhy{}15
\end{sphinxVerbatim}

\sphinxAtStartPar
Windows PowerShell

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{Start\PYGZhy{}Service} \PYG{n}{\PYGZhy{}Name} \PYG{n}{postgresql}\PYG{n}{\PYGZhy{}x64}\PYG{p}{\PYGZhy{}}\PYG{n}{15}
\end{sphinxVerbatim}


\subsection{Zatrzymywanie}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:zatrzymywanie}}
\sphinxAtStartPar
Linux:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }stop\PYG{+w}{ }postgresql
\end{sphinxVerbatim}

\sphinxAtStartPar
Windows CMD:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
net stop postgresql\PYGZhy{}x64\PYGZhy{}15
\end{sphinxVerbatim}

\sphinxAtStartPar
Windows PowerShell

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{Stop\PYGZhy{}Service} \PYG{n}{\PYGZhy{}Name} \PYG{n}{postgresql}\PYG{n}{\PYGZhy{}x64}\PYG{p}{\PYGZhy{}}\PYG{n}{15}
\end{sphinxVerbatim}


\subsection{Restartowanie}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:restartowanie}}
\sphinxAtStartPar
Linux:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo\PYG{+w}{ }systemctl\PYG{+w}{ }restart\PYG{+w}{ }postgresql
\end{sphinxVerbatim}

\sphinxAtStartPar
W CMD nie istnieje osobne polecenie restartowania. Należy zatrzymać serwer, a następnie uruchomić go ponownie.

\sphinxAtStartPar
Windows PowerShell

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{Restart\PYGZhy{}Service} \PYG{n}{\PYGZhy{}Name} \PYG{n}{postgresql}\PYG{n}{\PYGZhy{}x64}\PYG{p}{\PYGZhy{}}\PYG{n}{15}
\end{sphinxVerbatim}

\sphinxAtStartPar
Polecenia CMD mogą zostać również użyte w PowerShell.


\section{Zarządzanie połączeniami użytkowników}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:zarzadzanie-polaczeniami-uzytkownikow}}
\sphinxAtStartPar
Autor: Piotr Mikołajczyk

\sphinxAtStartPar
Oprócz sytuacji, gdy trzeba zamknąć dostęp do bazy danych na czas konserwacji, połączenia użytkowników należy ograniczyć także wtedy, gdy sesja użytkownika została zawieszona lub zbyt wiele połączeń skutkuje nadmiernym zużyciem pamięci i mocy obliczeniowej, uniemożliwiając nawiązywanie nowych połączeń i spowolniając działanie serwera.


\subsection{Ograniczanie użytkowników}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:ograniczanie-uzytkownikow}}
\sphinxAtStartPar
Istnieje kilka sposobów ograniczenia dostępu użytkownika:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Odebranie użytkownikowi prawa dostępu do bazy:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{REVOKE}\PYG{+w}{ }\PYG{k}{CONNECT}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{k}{DATABASE}\PYG{+w}{ }\PYG{n}{baza}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{k}{user}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxAtStartPar
Limit liczby jednoczesnych połączeń:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ALTER}\PYG{+w}{ }\PYG{k}{ROLE}\PYG{+w}{ }\PYG{k}{user}\PYG{+w}{ }\PYG{k}{CONNECTION}\PYG{+w}{ }\PYG{k}{LIMIT}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\end{itemize}


\subsection{Ręczne rozłączanie użytkowników}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:reczne-rozlaczanie-uzytkownikow}}
\sphinxAtStartPar
Według nazwy danego użytkownika:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}terminate\PYGZus{}backend}\PYG{p}{(}\PYG{n}{pid}\PYG{p}{)}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}stat\PYGZus{}activity}
\PYG{k}{WHERE}\PYG{+w}{ }\PYG{n}{usename}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}user\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Według PID (np. 12340):
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}\PYG{+w}{ }\PYG{n}{pg\PYGZus{}terminate\PYGZus{}backend}\PYG{p}{(}\PYG{l+m+mi}{12340}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}


\subsection{Automatyczne rozłączanie użytkowników}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:automatyczne-rozlaczanie-uzytkownikow}}
\sphinxAtStartPar
Sesja użytkownika lub jego zapytania mogą zostać rozłączone automatycznie, jeśli wprowadzimy pewne ograniczenia czasowe:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Rozłączenie sesji po przekroczeniu limitu czasu bezczynności podczas zapytania:
\begin{itemize}
\item {} 
\sphinxAtStartPar
dla bieżącej sesji:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SET}\PYG{+w}{ }\PYG{n}{idle\PYGZus{}in\PYGZus{}transaction\PYGZus{}session\PYGZus{}timeout}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}5min\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\item {} 
\sphinxAtStartPar
dla danego użytkownika:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ALTER}\PYG{+w}{ }\PYG{k}{ROLE}\PYG{+w}{ }\PYG{k}{user}\PYG{+w}{ }\PYG{k}{SET}\PYG{+w}{ }\PYG{n}{idle\PYGZus{}in\PYGZus{}transaction\PYGZus{}session\PYGZus{}timeout}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}5min\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\end{itemize}

\item {} 
\sphinxAtStartPar
Limit czasu zapytania:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ALTER}\PYG{+w}{ }\PYG{k}{ROLE}\PYG{+w}{ }\PYG{k}{user}\PYG{+w}{ }\PYG{k}{SET}\PYG{+w}{ }\PYG{n}{statement\PYGZus{}timeout}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+s1}{\PYGZsq{}30s\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\end{itemize}


\subsection{Zapobieganie nowym połączeniom}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:zapobieganie-nowym-polaczeniom}}
\sphinxAtStartPar
Zablokowanie logowania konkretnego użytkownika:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ALTER}\PYG{+w}{ }\PYG{k}{ROLE}\PYG{+w}{ }\PYG{k}{user}\PYG{+w}{ }\PYG{n}{NOLOGIN}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Odblokowanie:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{ALTER}\PYG{+w}{ }\PYG{k}{ROLE}\PYG{+w}{ }\PYG{k}{user}\PYG{+w}{ }\PYG{n}{LOGIN}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxAtStartPar
Blokowanie nowych połączeń do bazy danych:
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{REVOKE}\PYG{+w}{ }\PYG{k}{CONNECT}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{k}{DATABASE}\PYG{+w}{ }\PYG{n}{baza}\PYG{+w}{ }\PYG{k}{FROM}\PYG{+w}{ }\PYG{k}{PUBLIC}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
PUBLIC oznacza wszystkich użytkowników. Nadal połączeni użytkownicy nie są rozłączani.
\end{quote}


\section{Proces VACUUM}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:proces-vacuum}}
\sphinxAtStartPar
Autor: Piotr Mikołajczyk

\sphinxAtStartPar
DELETE nie usuwa rekordów z tabeli, jedynie oznacza je jako martwe. Podobnie UPDATE pozostawia stare wersje zaktualizowanych krotek.

\sphinxAtStartPar
Proces VACUUM przeszukuje tabele i indeksy, szukając martwych wierszy, które można fizycznie usunąć lub oznaczyć do nadpisania.

\sphinxAtStartPar
Może zostać przeprowadzony na kilka sposobów:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{VACUUM}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Usuwa martwe krotki, ale nie odzyskuje miejsca z dysku, a jedynie udostępnia je dla przyszłych danych,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{VACUUM}\PYG{+w}{ }\PYG{k}{FULL}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Kompaktuje tabelę do nowego pliku, zwalnia miejsce w pamięci,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{VACUUM}\PYG{+w}{ }\PYG{k}{ANALYZE}
\end{sphinxVerbatim}

\sphinxAtStartPar
Usuwa martwe krotki i przeprowadza aktualizację statystyk, nie odzyskuje miejsca.


\subsection{Autovacuum}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:autovacuum}}
\sphinxAtStartPar
Autovacuum działa w tle, automatycznie wykonując VACUUM na odpowiednich tabelach. Dzięki niemu nie trzeba ręcznie uruchamiać VACUUM po każdej modyfikacji tabeli. Autovacuum posiada wiele parametrów, od których zależy kiedy wykonany zostanie proces, między innymi:
\begin{itemize}
\item {} 
\sphinxAtStartPar
autovacuum \sphinxhyphen{} parametr logiczny, decyduje, czy serwer będzie uruchamiał launcher procesu autovacuum,

\item {} 
\sphinxAtStartPar
autovacuum\_max\_workers \sphinxhyphen{} liczba całkowita, określa maksymalną ilość procesów autovacuum mogących działać w tym samym czasie, domyślnie 3,

\item {} 
\sphinxAtStartPar
autovacuum\_vacuum\_threshold \sphinxhyphen{} liczba całkowita, określa ile wierszy w jednej tabeli musi zostać usunięte lub zmienione, aby wywołano VACUUM, domyślnie 50,

\item {} 
\sphinxAtStartPar
autovacuum\_vacuum\_scale\_factor \sphinxhyphen{} liczba zmiennoprzecinkowa, jaki procent tabeli musi zostać zmieniony aby wywołano VACUUM, domyślna wartość to 0.2 (20\%).

\end{itemize}

\sphinxAtStartPar
Analogiczne parametry warunkują również wywołanie ANALYZE, na przykład autovacuum\_analyze\_threshold.

\sphinxAtStartPar
Próg uruchamiania VACUUM ustala się wzorem:
\begin{quote}

\sphinxAtStartPar
autovacuum\_vacuum\_threshold + autovacuum\_vacuum\_scale\_factor * liczba\_wierszy
\end{quote}

\sphinxAtStartPar
Podobnie dla ANALYZE:
\begin{quote}

\sphinxAtStartPar
autovacuum\_analyze\_threshold + autovacuum\_analyze\_scale\_factor * liczba\_wierszy
\end{quote}


\section{Schemat bazy danych}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:schemat-bazy-danych}}
\sphinxAtStartPar
Autor: Bartłomiej Czyż


\subsection{Czym jest schemat bazy danych?}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:czym-jest-schemat-bazy-danych}}
\sphinxAtStartPar
Schemat bazy danych to logiczna struktura opisująca organizację danych, typy danych, relacje między tabelami, ograniczenia integralności, procedury składowane, widoki i inne obiekty. Innymi słowy, schemat jest „szkieletem” bazy danych.

\sphinxAtStartPar
Przykładowe elementy schematu:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Tabele (np. users, orders),

\item {} 
\sphinxAtStartPar
Typy danych (np. INT, VARCHAR, DATE),

\item {} 
\sphinxAtStartPar
Klucze główne i obce,

\item {} 
\sphinxAtStartPar
Indeksy,

\item {} 
\sphinxAtStartPar
Widoki (VIEW),

\item {} 
\sphinxAtStartPar
Procedury i funkcje (STORED PROCEDURES),

\item {} 
\sphinxAtStartPar
Ograniczenia (CHECK, NOT NULL, UNIQUE).

\end{itemize}


\subsection{Rola schematu w konserwacji bazy danych}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:rola-schematu-w-konserwacji-bazy-danych}}
\sphinxAtStartPar
Schemat ma kluczowe znaczenie dla utrzymania spójności i integralności danych, dlatego jego kontrola i konserwacja obejmuje m.in.:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Dokumentację schematu \sphinxhyphen{} niezbędna przy aktualizacjach i migracjach,

\item {} 
\sphinxAtStartPar
Weryfikację integralności relacji \sphinxhyphen{} sprawdzenie czy klucze obce i reguły są respektowane,

\item {} 
\sphinxAtStartPar
Normalizację \sphinxhyphen{} kontrola nad nadmiarem danych i poprawnością logiczną,

\item {} 
\sphinxAtStartPar
Aktualizacje schematu \sphinxhyphen{} np. dodawanie nowych kolumn, zmiana typu danych,

\item {} 
\sphinxAtStartPar
Kontrola zgodności \sphinxhyphen{} wersjonowanie schematu (np. za pomocą narzędzi typu Liquibase, Flyway),

\item {} 
\sphinxAtStartPar
Zabezpieczenia schematów \sphinxhyphen{} nadawanie uprawnień tylko zaufanym użytkownikom.

\end{itemize}

\sphinxAtStartPar
Przykład konserwacji:

\sphinxAtStartPar
W PostgreSQL można analizować i optymalizować strukturę przy pomocy pgAdmin oraz narzędzi takich jak pg\_dump –schema\sphinxhyphen{}only.


\subsection{Różnice w implementacji schematu w różnych systemach}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:roznice-w-implementacji-schematu-w-roznych-systemach}}\begin{itemize}
\item {} 
\sphinxAtStartPar
MySQL \sphinxhyphen{} obsługuje wiele schematów w jednej bazie; ograniczone typy kolumn w starszych wersjach,

\item {} 
\sphinxAtStartPar
PostgreSQL \sphinxhyphen{} bardzo elastyczny system schematów \sphinxhyphen{} możliwość teorzenia przestrzeni nazw,

\item {} 
\sphinxAtStartPar
SQLite \sphinxhyphen{} pojedynczy schemat, uproszczony system typów,

\item {} 
\sphinxAtStartPar
SQL Server \sphinxhyphen{} schemat jako logiczna przestrzeń obiektów, np. dbo, hr, finance.

\end{itemize}


\section{Transakcje}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:transakcje}}
\sphinxAtStartPar
Autor: Bartłomiej Czyż


\subsection{Czym jest transakcja?}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:czym-jest-transakcja}}
\sphinxAtStartPar
Transakcja to zbiór operacji na bazie danych, które są traktowane jako jedna, nierozdzielna całość. Albo wykonują się wszystkie operacje, albo żadna \sphinxhyphen{} zasada atomiczności. Transakcje są podstawą do zachowania spójności danych, szczególnie w środowiskach wieloużytkownikowych.


\subsection{Zasady ACID}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:zasady-acid}}
\sphinxAtStartPar
Transakcje w bazach danych opierają się na czterech podstawowych zasadach, znanych jako ACID:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A \sphinxhyphen{} Atomicity (Atomowość) \sphinxhyphen{} operacje wchodzące w skład transakcji są niepodzielne \sphinxhyphen{} wszystkie muszą się powieść, lub wszystkie są wycofywane,

\item {} 
\sphinxAtStartPar
C \sphinxhyphen{} Consistency (Spójność) \sphinxhyphen{} transakcje przekształcają dane ze stanu spójnego w stan spójny,

\item {} 
\sphinxAtStartPar
I \sphinxhyphen{} Isolation (Izolacja) \sphinxhyphen{} równoczesne transakcje nie wpływają na siebie nawzajem,

\item {} 
\sphinxAtStartPar
D \sphinxhyphen{} Durability (Trwałość) \sphinxhyphen{} po zatwierdzeniu transakcji dane są trwale zapisane, nawet w przypadku awarii.

\end{itemize}


\subsection{Rola transakcji w kontroli i konserwacji}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:rola-transakcji-w-kontroli-i-konserwacji}}
\sphinxAtStartPar
Transakcje mają ogromne znaczenie dla bezpieczeństwa danych, dlatego są nieodłącznym elementem procesów konserwacyjnych. Ich zastosowanie obejmuje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Zabezpieczenie operacji aktualizacji \sphinxhyphen{} np. przy masowych zmianach danych,

\item {} 
\sphinxAtStartPar
Replikacja i synchronizacja danych \sphinxhyphen{} transakcje zapewniają spójność między główną bazą, a replikami,

\item {} 
\sphinxAtStartPar
Zarządzanie błędami \sphinxhyphen{} w przypadku błędu można wykonać ROLLBACK i przywrócić stan bazy,

\item {} 
\sphinxAtStartPar
Tworzenie backupów spójnych z punktu w czasie \sphinxhyphen{} snapshoty danych często wymagają wsparcia transakcyjnego,

\item {} 
\sphinxAtStartPar
Ochrona przed uszkodzeniami logicznymi \sphinxhyphen{} np. przez niekompletne aktualizacje.

\end{itemize}


\subsection{Różnice w implementacji transakcji w różnych systemach}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:roznice-w-implementacji-transakcji-w-roznych-systemach}}\begin{itemize}
\item {} 
\sphinxAtStartPar
MySQL \sphinxhyphen{} w pełni wspierane w silniku InnoDB; START TRANSACTION, COMMIT, ROLLBACK,

\item {} 
\sphinxAtStartPar
PostgreSQL \sphinxhyphen{} silne wsparcie ACID, zaawansowana izolacja (REPEATABLE READ, SERIALIZABLE),

\item {} 
\sphinxAtStartPar
SQLite \sphinxhyphen{} transakcje działają w trybie plikowym; BEGIN, COMMIT i ROLLBACK są wspierane,

\item {} 
\sphinxAtStartPar
SQL Server \sphinxhyphen{} zaawansowany mechanizm transakcji z kontrolą poziomów izolacji, także eksplicytny SAVEPOINT.

\end{itemize}


\section{Literatura}
\label{\detokenize{Kontrola_i_konserwacja/kontrola_i_konserwacja:literatura}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.postgresql.org/docs/current/index.html}{Oficjalna dokumentacja PostgreSQL}

\item {} 
\sphinxAtStartPar
Riggs S., Krosing H., PostgreSQL. Receptury dla administratora, Helion 2011

\item {} 
\sphinxAtStartPar
Matthew N., Stones R., Beginning Databases with PostgreSQL. From Novice to Professional, Apress 2006

\item {} 
\sphinxAtStartPar
Juba S., Vannahme A., Volkov A., Learning PostgreSQL, Packt Publishing 2015

\end{itemize}

\sphinxstepscope


\chapter{Kopie zapasowe i odzyskiwanie danych w PostgreSQL}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:kopie-zapasowe-i-odzyskiwanie-danych-w-postgresql}}\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych::doc}}\begin{quote}\begin{description}
\sphinxlineitem{Autorzy}
\sphinxAtStartPar
Miłosz Śmieja Szymon Piskorz Mateusz Wasilewicz

\end{description}\end{quote}


\section{Wprowadzenie}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:wprowadzenie}}
\sphinxAtStartPar
System zarządzania bazą danych PostgreSQL oferuje kompleksowy zestaw narzędzi i mechanizmów służących do tworzenia kopii zapasowych oraz odzyskiwania danych. Skuteczne zarządzanie kopiami zapasowymi stanowi fundament bezpieczeństwa danych i ciągłości działania systemów bazodanowych.

\sphinxAtStartPar
PostgreSQL dostarcza zarówno mechanizmy wbudowane, jak i możliwość integracji z zewnętrznymi narzędziami automatyzacji.


\section{Mechanizmy wbudowane do tworzenia kopii zapasowych całego systemu PostgreSQL}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:mechanizmy-wbudowane-do-tworzenia-kopii-zapasowych-calego-systemu-postgresql}}
\sphinxAtStartPar
PostgreSQL oferuje kilka mechanizmów tworzenia kopii zapasowych na poziomie całego systemu, które zapewniają kompleksową ochronę wszystkich baz danych w klastrze.


\subsection{pg\_basebackup}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:pg-basebackup}}
\sphinxAtStartPar
\sphinxstylestrong{pg\_basebackup} stanowi podstawowe narzędzie do tworzenia fizycznych kopii zapasowych całego klastra PostgreSQL.

\sphinxAtStartPar
Kluczowe cechy:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Działa w trybie online \sphinxhyphen{} możliwość wykonywania kopii zapasowych bez zatrzymywania działania serwera

\item {} 
\sphinxAtStartPar
Tworzy dokładną kopię wszystkich plików danych

\item {} 
\sphinxAtStartPar
Zawiera pliki konfiguracyjne, dzienniki transakcji oraz wszystkie bazy danych w klastrze

\end{itemize}


\subsection{Continuous Archiving (Point\sphinxhyphen{}in\sphinxhyphen{}Time Recovery)}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:continuous-archiving-point-in-time-recovery}}
\sphinxAtStartPar
\sphinxstylestrong{Continuous Archiving} reprezentuje zaawansowany mechanizm tworzenia ciągłych kopii zapasowych poprzez archiwizację dzienników WAL (Write\sphinxhyphen{}Ahead Logging).

\sphinxAtStartPar
Zalety:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Umożliwia odtworzenie stanu bazy danych w dowolnym momencie czasowym

\item {} 
\sphinxAtStartPar
Szczególnie wartościowe w środowiskach produkcyjnych wymagających minimalnej utraty danych

\item {} 
\sphinxAtStartPar
Zapewnia wysoką granularność odzyskiwania danych

\end{itemize}


\subsection{Streaming Replication}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:streaming-replication}}
\sphinxAtStartPar
\sphinxstylestrong{Streaming Replication} może służyć jako mechanizm kopii zapasowych poprzez utrzymywanie synchronicznych lub asynchronicznych replik głównej bazy danych.

\sphinxAtStartPar
Funkcjonalności:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Repliki funkcjonują jako kopie zapasowe w czasie rzeczywistym

\item {} 
\sphinxAtStartPar
Oferuje możliwość szybkiego przełączenia w przypadku awarii systemu głównego

\item {} 
\sphinxAtStartPar
Wspiera zarówno tryb synchroniczny, jak i asynchroniczny

\end{itemize}


\subsection{File System Level Backup}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:file-system-level-backup}}
\sphinxAtStartPar
\sphinxstylestrong{File System Level Backup} polega na tworzeniu kopii zapasowych na poziomie systemu plików.

\sphinxAtStartPar
Wymagania:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Zatrzymanie serwera PostgreSQL lub zapewnienie spójności

\item {} 
\sphinxAtStartPar
Wykorzystanie mechanizmów snapshot systemu plików:
\begin{itemize}
\item {} 
\sphinxAtStartPar
LVM snapshots

\item {} 
\sphinxAtStartPar
ZFS snapshots

\end{itemize}

\end{itemize}


\section{Mechanizmy wbudowane do tworzenia kopii zapasowych poszczególnych baz danych}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:mechanizmy-wbudowane-do-tworzenia-kopii-zapasowych-poszczegolnych-baz-danych}}
\sphinxAtStartPar
PostgreSQL dostarcza precyzyjne narzędzia umożliwiające tworzenie kopii zapasowych pojedynczych baz danych lub ich wybranych elementów.


\subsection{pg\_dump}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:pg-dump}}
\sphinxAtStartPar
\sphinxstylestrong{pg\_dump} stanowi najczęściej wykorzystywane narzędzie do tworzenia logicznych kopii zapasowych pojedynczych baz danych.

\sphinxAtStartPar
Charakterystyka:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Tworzy skrypt SQL zawierający wszystkie polecenia niezbędne do odtworzenia struktury bazy danych oraz jej danych

\item {} 
\sphinxAtStartPar
Oferuje liczne opcje konfiguracji:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Możliwość wyboru formatu wyjściowego

\item {} 
\sphinxAtStartPar
Filtrowanie obiektów

\item {} 
\sphinxAtStartPar
Kontrola nad poziomem szczegółowości kopii zapasowej

\end{itemize}

\end{itemize}


\subsection{pg\_dumpall}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:pg-dumpall}}
\sphinxAtStartPar
\sphinxstylestrong{pg\_dumpall} rozszerza funkcjonalność \sphinxcode{\sphinxupquote{pg\_dump}} o możliwość tworzenia kopii zapasowych wszystkich baz danych w klastrze.

\sphinxAtStartPar
Dodatkowe funkcje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Backup obiektów globalnych:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Role użytkowników

\item {} 
\sphinxAtStartPar
Tablespaces

\item {} 
\sphinxAtStartPar
Ustawienia konfiguracyjne na poziomie klastra

\end{itemize}

\end{itemize}


\subsection{COPY command}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:copy-command}}
\sphinxAtStartPar
\sphinxstylestrong{COPY command} umożliwia eksport danych z poszczególnych tabel do plików w różnych formatach.

\sphinxAtStartPar
Obsługiwane formaty:
\begin{itemize}
\item {} 
\sphinxAtStartPar
CSV

\item {} 
\sphinxAtStartPar
Text

\item {} 
\sphinxAtStartPar
Binary

\end{itemize}

\sphinxAtStartPar
Zastosowania:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Tworzenie selektywnych kopii zapasowych dużych tabel

\item {} 
\sphinxAtStartPar
Migracje danych

\end{itemize}


\subsection{pg\_dump z opcjami selektywnymi}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:pg-dump-z-opcjami-selektywnymi}}
\sphinxAtStartPar
\sphinxstylestrong{pg\_dump z opcjami selektywnymi} pozwala na tworzenie kopii zapasowych wybranych obiektów bazy danych.

\sphinxAtStartPar
Możliwości filtrowania:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Konkretne tabele

\item {} 
\sphinxAtStartPar
Schematy

\item {} 
\sphinxAtStartPar
Sekwencje

\end{itemize}

\sphinxAtStartPar
Funkcjonalność ta jest nieoceniona w scenariuszach wymagających granularnej kontroli nad procesem tworzenia kopii zapasowych.


\section{Odzyskiwanie usuniętych lub uszkodzonych danych}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:odzyskiwanie-usunietych-lub-uszkodzonych-danych}}
\sphinxAtStartPar
PostgreSQL oferuje różnorodne mechanizmy odzyskiwania danych w zależności od rodzaju i zakresu uszkodzeń.


\subsection{Odzyskiwanie z kopii logicznych}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:odzyskiwanie-z-kopii-logicznych}}
\sphinxAtStartPar
\sphinxstylestrong{Odzyskiwanie z kopii logicznych} wykonanych przy użyciu \sphinxcode{\sphinxupquote{pg\_dump}} realizowane jest poprzez \sphinxcode{\sphinxupquote{psql}} lub \sphinxcode{\sphinxupquote{pg\_restore}}.

\sphinxAtStartPar
Proces odzyskiwania:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Wykonanie skryptów SQL

\item {} 
\sphinxAtStartPar
Przywrócenie plików dump w odpowiednim formacie

\end{itemize}

\sphinxAtStartPar
Zaawansowane opcje pg\_restore:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Selektywne przywracanie obiektów

\item {} 
\sphinxAtStartPar
Równoległe przetwarzanie

\item {} 
\sphinxAtStartPar
Kontrola nad kolejnością przywracania

\end{itemize}


\subsection{Point\sphinxhyphen{}in\sphinxhyphen{}Time Recovery (PITR)}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:point-in-time-recovery-pitr}}
\sphinxAtStartPar
\sphinxstylestrong{Point\sphinxhyphen{}in\sphinxhyphen{}Time Recovery (PITR)} umożliwia przywrócenie bazy danych do konkretnego momentu w czasie.

\sphinxAtStartPar
Wykorzystywane komponenty:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Kombinacja kopii bazowej

\item {} 
\sphinxAtStartPar
Archiwalne dzienniki WAL

\end{itemize}

\sphinxAtStartPar
Zastosowania:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cofnięcie zmian do momentu poprzedzającego wystąpienie błędu

\item {} 
\sphinxAtStartPar
Odzyskiwanie po uszkodzeniu danych

\end{itemize}

\begin{sphinxadmonition}{note}{Informacja:}
\sphinxAtStartPar
PITR jest szczególnie wartościowy w przypadkach, gdy konieczne jest cofnięcie zmian do momentu poprzedzającego wystąpienie błędu lub uszkodzenia.
\end{sphinxadmonition}


\subsection{Odzyskiwanie tabel z tablespaces}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:odzyskiwanie-tabel-z-tablespaces}}
\sphinxAtStartPar
\sphinxstylestrong{Odzyskiwanie tabel z tablespaces} może wymagać specjalnych procedur w przypadku uszkodzenia przestrzeni tabel.

\sphinxAtStartPar
Możliwości PostgreSQL:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Odtworzenie tablespaces

\item {} 
\sphinxAtStartPar
Przeniesienie tabel między różnymi lokalizacjami

\item {} 
\sphinxAtStartPar
Odzyskiwanie danych nawet w przypadku częściowego uszkodzenia systemu plików

\end{itemize}


\subsection{Transaction log replay}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:transaction-log-replay}}
\sphinxAtStartPar
\sphinxstylestrong{Transaction log replay} wykorzystuje dzienniki WAL do odtworzenia zmian wprowadzonych po utworzeniu kopii zapasowej.

\sphinxAtStartPar
Charakterystyka:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Automatycznie wykorzystywany podczas standardowych procedur odzyskiwania

\item {} 
\sphinxAtStartPar
Możliwość ręcznej kontroli w szczególnych sytuacjach

\end{itemize}


\subsection{Odzyskiwanie na poziomie klastra}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:odzyskiwanie-na-poziomie-klastra}}
\sphinxAtStartPar
\sphinxstylestrong{Odzyskiwanie na poziomie klastra} przy wykorzystaniu \sphinxcode{\sphinxupquote{pg\_basebackup}} wymaga przywrócenia wszystkich plików klastra oraz odpowiedniej konfiguracji parametrów recovery.

\sphinxAtStartPar
Zakres procesu:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Odtworzenie całego środowiska PostgreSQL

\item {} 
\sphinxAtStartPar
Konfiguracja ról i uprawnień

\item {} 
\sphinxAtStartPar
Przywrócenie ustawień systemowych

\end{itemize}


\section{Dedykowane oprogramowanie i skrypty zewnętrzne do automatyzacji}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:dedykowane-oprogramowanie-i-skrypty-zewnetrzne-do-automatyzacji}}
\sphinxAtStartPar
Automatyzacja procesów tworzenia kopii zapasowych stanowi kluczowy element profesjonalnego zarządzania bazami danych PostgreSQL.


\subsection{pgBackRest}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:pgbackrest}}
\sphinxAtStartPar
\sphinxstylestrong{pgBackRest} reprezentuje kompleksowe rozwiązanie do zarządzania kopiami zapasowymi PostgreSQL.

\sphinxAtStartPar
Zaawansowane funkcje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Incremental i differential backups

\item {} 
\sphinxAtStartPar
Kompresja danych

\item {} 
\sphinxAtStartPar
Szyfrowanie

\item {} 
\sphinxAtStartPar
Weryfikacja integralności kopii

\item {} 
\sphinxAtStartPar
Możliwość przechowywania kopii w chmurze

\item {} 
\sphinxAtStartPar
Automatyzacja procesów zarządzania kopiami zapasowymi

\item {} 
\sphinxAtStartPar
Uproszczone procedury odzyskiwania

\end{itemize}

\begin{sphinxadmonition}{important}{Ważne:}
\sphinxAtStartPar
pgBackRest automatyzuje wiele procesów związanych z zarządzaniem kopiami zapasowymi i znacznie upraszcza procedury odzyskiwania.
\end{sphinxadmonition}


\subsection{Barman (Backup and Recovery Manager)}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:barman-backup-and-recovery-manager}}
\sphinxAtStartPar
\sphinxstylestrong{Barman} stanowi dedykowane narzędzie stworzone przez 2ndQuadrant do zarządzania kopiami zapasowymi PostgreSQL w środowiskach enterprise.

\sphinxAtStartPar
Kluczowe funkcjonalności:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Centralne zarządzanie kopiami zapasowymi wielu serwerów PostgreSQL

\item {} 
\sphinxAtStartPar
Monitoring procesów backup

\item {} 
\sphinxAtStartPar
Automatyczne testowanie procedur recovery

\item {} 
\sphinxAtStartPar
Integracja z narzędziami monitorowania

\end{itemize}


\subsection{WAL\sphinxhyphen{}E i WAL\sphinxhyphen{}G}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:wal-e-i-wal-g}}
\sphinxAtStartPar
\sphinxstylestrong{WAL\sphinxhyphen{}E i WAL\sphinxhyphen{}G} specjalizują się w archiwizacji dzienników WAL w środowiskach chmurowych.

\sphinxAtStartPar
Oferowane funkcje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Efektywna kompresja

\item {} 
\sphinxAtStartPar
Szyfrowanie danych

\item {} 
\sphinxAtStartPar
Przechowywanie kopii zapasowych w serwisach chmurowych:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Amazon S3

\item {} 
\sphinxAtStartPar
Google Cloud Storage

\item {} 
\sphinxAtStartPar
Azure Blob Storage

\end{itemize}

\end{itemize}


\subsection{Skrypty shell i cron jobs}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:skrypty-shell-i-cron-jobs}}
\sphinxAtStartPar
\sphinxstylestrong{Skrypty shell i cron jobs} stanowią tradycyjne podejście do automatyzacji kopii zapasowych.

\sphinxAtStartPar
Możliwości automatyzacji:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Wykonywanie \sphinxcode{\sphinxupquote{pg\_dump}} i \sphinxcode{\sphinxupquote{pg\_basebackup}}

\item {} 
\sphinxAtStartPar
Zarządzanie cyklem życia kopii zapasowych

\item {} 
\sphinxAtStartPar
Rotacja i czyszczenie starych kopii

\end{itemize}

\begin{sphinxadmonition}{tip}{Wskazówka:}
\sphinxAtStartPar
Właściwie napisane skrypty mogą automatyzować wykonywanie pg\_dump, pg\_basebackup oraz zarządzanie cyklem życia kopii zapasowych, w tym rotację i czyszczenie starych kopii.
\end{sphinxadmonition}


\subsection{Narzędzia automatyzacji infrastruktury}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:narzedzia-automatyzacji-infrastruktury}}
\sphinxAtStartPar
\sphinxstylestrong{Ansible, Puppet, Chef} jako narzędzia automatyzacji infrastruktury mogą być wykorzystywane do zarządzania konfiguracją procesów backup na większą skalę.

\sphinxAtStartPar
Korzyści:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Standaryzacja procedur backup w środowiskach wieloserwerowych

\item {} 
\sphinxAtStartPar
Zapewnienie konsystentności konfiguracji

\item {} 
\sphinxAtStartPar
Skalowalne zarządzanie infrastrukturą

\end{itemize}


\subsection{Monitoring i alertowanie}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:monitoring-i-alertowanie}}
\sphinxAtStartPar
\sphinxstylestrong{Prometheus i Grafana} w połączeniu z \sphinxcode{\sphinxupquote{postgres\_exporter}} umożliwiają monitoring procesów backup oraz alertowanie w przypadku niepowodzeń.

\sphinxAtStartPar
Zakres monitorowania:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Śledzenie czasu wykonywania kopii

\item {} 
\sphinxAtStartPar
Monitorowanie rozmiaru kopii zapasowych

\item {} 
\sphinxAtStartPar
Wskaźnik sukcesu procesów backup

\item {} 
\sphinxAtStartPar
Alertowanie w czasie rzeczywistym

\end{itemize}


\section{Podsumowanie}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:podsumowanie}}
\sphinxAtStartPar
Skuteczne zarządzanie kopiami zapasowymi w PostgreSQL wymaga kombinacji mechanizmów wbudowanych oraz zewnętrznych narzędzi automatyzacji. Wybór odpowiedniej strategii backup zależy od specyficznych wymagań organizacji, w tym:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{RTO (Recovery Time Objective)} \sphinxhyphen{} maksymalny akceptowalny czas odzyskiwania

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{RPO (Recovery Point Objective)} \sphinxhyphen{} maksymalna akceptowalna utrata danych

\item {} 
\sphinxAtStartPar
Dostępne zasoby

\item {} 
\sphinxAtStartPar
Złożoność środowiska

\end{itemize}


\subsection{Kluczowe wnioski}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:kluczowe-wnioski}}
\sphinxAtStartPar
\sphinxstylestrong{Mechanizmy wbudowane} PostgreSQL, takie jak \sphinxcode{\sphinxupquote{pg\_dump}}, \sphinxcode{\sphinxupquote{pg\_basebackup}} czy PITR, oferują solidne podstawy dla większości scenariuszy backup i recovery.

\sphinxAtStartPar
\sphinxstylestrong{W środowiskach produkcyjnych} o wysokich wymaganiach dotyczących dostępności i niezawodności, integracja z dedykowanymi narzędziami takimi jak pgBackRest czy Barman staje się niezbędna.


\subsection{Najważniejsze zalecenia}
\label{\detokenize{Kopie_zapasowe_i_odzyskiwanie_danych/kopie_zapasowe_i_odzyskiwanie_danych:najwazniejsze-zalecenia}}
\begin{sphinxadmonition}{warning}{Ostrzeżenie:}
\sphinxAtStartPar
Kluczowym elementem każdej strategii backup jest regularne testowanie procedur odzyskiwania danych. Kopie zapasowe mają wartość tylko wtedy, gdy można z nich skutecznie odzyskać dane w sytuacji kryzysowej.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{Kompleksowa strategia backup} powinna obejmować:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Tworzenie kopii zapasowych

\item {} 
\sphinxAtStartPar
Regularne testy restore

\item {} 
\sphinxAtStartPar
Dokumentację procedur

\item {} 
\sphinxAtStartPar
Szkolenie personelu odpowiedzialnego za zarządzanie bazami danych

\end{enumerate}

\sphinxstepscope


\chapter{Projekt i Implementacja Bazy Danych}
\label{\detokenize{rozdzial_3:projekt-i-implementacja-bazy-danych}}\label{\detokenize{rozdzial_3:rozdzial-3}}\label{\detokenize{rozdzial_3::doc}}
\sphinxAtStartPar
W niniejszym rozdziale przedstawiono kompletny projekt bazy danych „Sklep”. Proces został podzielony na trzy kluczowe etapy: od ogólnego modelu koncepcyjnego, przez szczegółowy model logiczny, aż po model fizyczny w postaci schematu SQL i kodu generatora.


\section{Model Koncepcyjny}
\label{\detokenize{rozdzial_3:model-koncepcyjny}}
\sphinxAtStartPar
Model koncepcyjny definiuje kluczowe byty biznesowe oraz fundamentalne relacje między nimi. Stanowi on wysokopoziomową mapę systemu, która identyfikuje główne obiekty i ich wzajemne powiązania.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=0.900\linewidth]{{model_konceptualny}.png}
\caption{\sphinxstylestrong{Rysunek 1: Model koncepcyjny.} Widoczne są główne encje: Klient, Zamówienie, Produkt, Kategoria, Dostawca oraz Pozycje Zamówienia, a także powiązania między nimi, takie jak „składa”, „zawiera” czy „dostarcza”.}\label{\detokenize{rozdzial_3:id1}}\end{figure}


\section{Model Logiczny}
\label{\detokenize{rozdzial_3:model-logiczny}}
\sphinxAtStartPar
Model logiczny jest uszczegółowieniem modelu koncepcyjnego. Definiuje on strukturę tabel, atrybuty (kolumny) dla każdej z nich oraz klucze główne (PK) i obce (FK), które zapewniają integralność relacyjną. Jest on niezależny od konkretnego systemu zarządzania bazą danych.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{model_logiczny}.png}
\caption{\sphinxstylestrong{Rysunek 2: Model logiczny.} Szczegółowo przedstawia strukturę każdej tabeli, w tym nazwy pól, ich typy generyczne oraz powiązania zrealizowane za pomocą kluczy obcych.}\label{\detokenize{rozdzial_3:id2}}\end{figure}


\section{Model Fizyczny (Schemat SQL)}
\label{\detokenize{rozdzial_3:model-fizyczny-schemat-sql}}
\sphinxAtStartPar
Model fizyczny to konkretna implementacja modelu logicznego w wybranym systemie DBMS (w tym przypadku PostgreSQL i SQLite). Definiuje on precyzyjne typy danych (np. \sphinxtitleref{VARCHAR(100)}, \sphinxtitleref{NUMERIC(10,2)}), indeksy i inne elementy specyficzne dla danej technologii. Poniżej przedstawiono schemat dla bazy PostgreSQL.
\sphinxSetupCaptionForVerbatim{Fizyczny schemat bazy danych dla PostgreSQL}
\def\sphinxLiteralBlockLabel{\label{\detokenize{rozdzial_3:schema-postgres-sql}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{+w}{ }\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Kategorie}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{     }\PYG{n}{kategoria\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{nazwa\PYGZus{}kategorii}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{opis}\PYG{+w}{ }\PYG{n+nb}{TEXT}
\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{ }\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Dostawcy}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{     }\PYG{n}{dostawca\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{nazwa\PYGZus{}firmy}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{telefon}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{email}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}
\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{ }\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Klienci}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{     }\PYG{n}{klient\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{imie}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{nazwisko}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{email}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{+w}{ }\PYG{k}{UNIQUE}
\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{ }\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Produkty}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{     }\PYG{n}{produkt\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{nazwa\PYGZus{}produktu}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{cena}\PYG{+w}{ }\PYG{n+nb}{NUMERIC}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{stan\PYGZus{}magazynowy}\PYG{+w}{ }\PYG{n+nb}{INT}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{kategoria\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INT}\PYG{+w}{ }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Kategorie}\PYG{p}{(}\PYG{n}{kategoria\PYGZus{}id}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{dostawca\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INT}\PYG{+w}{ }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Dostawcy}\PYG{p}{(}\PYG{n}{dostawca\PYGZus{}id}\PYG{p}{)}
\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{ }\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Zamowienia}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{     }\PYG{n}{zamowienie\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{klient\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INT}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{+w}{ }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Klienci}\PYG{p}{(}\PYG{n}{klient\PYGZus{}id}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{data\PYGZus{}zamowienia}\PYG{+w}{ }\PYG{k}{TIMESTAMP}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{status}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}
\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{ }\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{PozycjeZamowienia}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{     }\PYG{n}{pozycja\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{zamowienie\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INT}\PYG{+w}{ }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Zamowienia}\PYG{p}{(}\PYG{n}{zamowienie\PYGZus{}id}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{produkt\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INT}\PYG{+w}{ }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Produkty}\PYG{p}{(}\PYG{n}{produkt\PYGZus{}id}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{ilosc}\PYG{+w}{ }\PYG{n+nb}{INT}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{     }\PYG{n}{cena}\PYG{+w}{ }\PYG{n+nb}{DECIMAL}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}
\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Opis Tabel}
\label{\detokenize{rozdzial_3:opis-tabel}}
\sphinxAtStartPar
Poniżej znajduje się szczegółowy opis przeznaczenia każdej z tabel.


\subsection{Klienci}
\label{\detokenize{rozdzial_3:klienci}}\begin{description}
\sphinxlineitem{Przechowuje informacje o klientach sklepu.}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{klient\_id}} (PK): Unikalny identyfikator klienta.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{imie}}, \sphinxcode{\sphinxupquote{nazwisko}}: Dane osobowe.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{email}} (UNIQUE): Unikalny adres email służący do kontaktu i logowania.

\end{itemize}

\end{description}


\subsection{Kategorie}
\label{\detokenize{rozdzial_3:kategorie}}\begin{description}
\sphinxlineitem{Słownik kategorii, do których przypisane są produkty.}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kategoria\_id}} (PK): Unikalny identyfikator kategorii.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nazwa\_kategorii}}: Nazwa, np. „Nabiał”, „Pieczywo”.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{opis}}: Dodatkowy opis kategorii.

\end{itemize}

\end{description}


\subsection{Dostawcy}
\label{\detokenize{rozdzial_3:dostawcy}}\begin{description}
\sphinxlineitem{Tabela przechowująca dane o dostawcach towaru.}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dostawca\_id}} (PK): Unikalny identyfikator dostawcy.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nazwa\_firmy}}, \sphinxcode{\sphinxupquote{telefon}}, \sphinxcode{\sphinxupquote{email}}: Dane kontaktowe dostawcy.

\end{itemize}

\end{description}


\subsection{Produkty}
\label{\detokenize{rozdzial_3:produkty}}\begin{description}
\sphinxlineitem{Główna tabela z informacjami o wszystkich produktach dostępnych w sklepie.}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{produkt\_id}} (PK): Unikalny identyfikator produktu.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nazwa\_produktu}}, \sphinxcode{\sphinxupquote{cena}}: Podstawowe informacje o produkcie.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{stan\_magazynowy}}: Liczba dostępnych sztuk.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{kategoria\_id}} (FK): Klucz obcy łączący z tabelą \sphinxcode{\sphinxupquote{Kategorie}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{dostawca\_id}} (FK): Klucz obcy łączący z tabelą \sphinxcode{\sphinxupquote{Dostawcy}}.

\end{itemize}

\end{description}


\subsection{Zamowienia}
\label{\detokenize{rozdzial_3:zamowienia}}\begin{description}
\sphinxlineitem{Przechowuje informacje o zamówieniach złożonych przez klientów.}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zamowienie\_id}} (PK): Unikalny identyfikator zamówienia.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{klient\_id}} (FK): Klucz obcy wskazujący, który klient złożył zamówienie.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{data\_zamowienia}}: Data i godzina złożenia zamówienia.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{status}}: Aktualny status, np. „Złożone”, „Wysłane”, „Anulowane”.

\end{itemize}

\end{description}


\subsection{PozycjeZamowienia}
\label{\detokenize{rozdzial_3:pozycjezamowienia}}\begin{description}
\sphinxlineitem{Tabela asocjacyjna (łącząca) zamówienia z produktami. Określa, jakie produkty i w jakiej ilości znalazły się w danym zamówieniu.}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pozycja\_id}} (PK): Unikalny identyfikator pozycji.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{zamowienie\_id}} (FK): Klucz obcy łączący z tabelą \sphinxcode{\sphinxupquote{Zamowienia}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{produkt\_id}} (FK): Klucz obcy łączący z tabelą \sphinxcode{\sphinxupquote{Produkty}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ilosc}}: Liczba sztuk danego produktu w zamówieniu.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{cena}}: Cena produktu w momencie zakupu (zapisana, aby uniknąć problemów przy zmianie ceny produktu w przyszłości).

\end{itemize}

\end{description}


\section{Kod Źródłowy Generatora Bazy Danych}
\label{\detokenize{rozdzial_3:kod-zrodlowy-generatora-bazy-danych}}
\sphinxAtStartPar
Pełna implementacja, wraz z logiką do generowania danych testowych, znajduje się w poniższym skrypcie. Został on użyty do automatycznego stworzenia schematów dla SQLite i PostgreSQL oraz wypełnienia ich danymi.
\sphinxSetupCaptionForVerbatim{generator\_bazy\_danych.py}
\def\sphinxLiteralBlockLabel{\label{\detokenize{rozdzial_3:generator-bazy-danych-py}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{Generator Bazy Danych \PYGZdq{}Sklep\PYGZdq{}}

\PYG{l+s+sd}{Moduł ten dostarcza kompletne rozwiązanie do automatycznego tworzenia}
\PYG{l+s+sd}{i wypełniania danymi testowymi bazy danych dla dwóch różnych systemów:}
\PYG{l+s+sd}{SQLite oraz PostgreSQL.}

\PYG{l+s+sd}{Został zaprojektowany z myślą o braku zewnętrznych zależności, co gwarantuje}
\PYG{l+s+sd}{jego działanie w każdym standardowym środowisku Python 3.}
\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{sqlite3}
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{random}
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{os}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{datetime}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{datetime}\PYG{p}{,} \PYG{n}{timedelta}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Konfiguracja parametrów skryptu \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{DB\PYGZus{}NAME\PYGZus{}SQLITE} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sklep.db}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{OUTPUT\PYGZus{}SQL\PYGZus{}POSTGRES} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sklep\PYGZus{}postgres.sql}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Liczba rekordów do wygenerowania}
\PYG{n}{NUM\PYGZus{}KLIENCI} \PYG{o}{=} \PYG{l+m+mi}{50}
\PYG{n}{NUM\PYGZus{}PRODUKTY} \PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{n}{NUM\PYGZus{}ZAMOWIENIA} \PYG{o}{=} \PYG{l+m+mi}{150}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Statyczne dane jako źródło dla generatora \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{IMIONA\PYGZus{}M} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Piotr}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Krzysztof}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Andrzej}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tomasz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Paweł}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Marcin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Michał}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{IMIONA\PYGZus{}K} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Anna}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Katarzyna}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Maria}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Małgorzata}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Agnieszka}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Barbara}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ewa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Elżbieta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{NAZWISKA} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Nowak}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Kowalski}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Wiśniewski}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Wójcik}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Kowalczyk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Kamiński}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Lewandowski}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Zieliński}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{CZESCI\PYGZus{}PRODUKTU\PYGZus{}1} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Chleb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ser}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mleko}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jogurt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Szynka}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sok}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Woda}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Masło}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Jajka}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Makaron}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{CZESCI\PYGZus{}PRODUKTU\PYGZus{}2} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wiejski}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{naturalny}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{świeży}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tradycyjny}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ekologiczny}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pełnoziarnisty}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{owocowy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gazowana}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{KATEGORIE} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pieczywo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Świeże chleby, bułki i wyroby cukiernicze.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Nabiał}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mleko, sery, jogurty i inne produkty mleczne.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Napoje}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Soki, wody mineralne i napoje gazowane.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Produkty sypkie}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mąka, cukier, ryż, makarony.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{]}
\PYG{n}{DOSTAWCY} \PYG{o}{=} \PYG{p}{[}
    \PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Piekarnia }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Złoty Kłos}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{111\PYGZhy{}222\PYGZhy{}333}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{kontakt@zlotyklos.pl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Mleczarnia }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Łąka}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{444\PYGZhy{}555\PYGZhy{}666}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{biuro@mleczarnia\PYGZhy{}laka.com}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Hurtownia }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{Napojex}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{777\PYGZhy{}888\PYGZhy{}999}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zamowienia@napojex.pl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Rolnik }\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{EkoZbiory}\PYG{l+s+s1}{\PYGZdq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{123\PYGZhy{}456\PYGZhy{}789}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rolnik@ekozbiory.pl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} \PYGZhy{}\PYGZhy{}\PYGZhy{} Definicje schematów SQL \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n}{SCHEMA\PYGZus{}SQLITE} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{CREATE TABLE Kategorie (}
\PYG{l+s+s2}{    kategoria\PYGZus{}id INTEGER PRIMARY KEY,}
\PYG{l+s+s2}{    nazwa\PYGZus{}kategorii TEXT NOT NULL,}
\PYG{l+s+s2}{    opis TEXT}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{CREATE TABLE Dostawcy (}
\PYG{l+s+s2}{    dostawca\PYGZus{}id INTEGER PRIMARY KEY,}
\PYG{l+s+s2}{    nazwa\PYGZus{}firmy TEXT NOT NULL,}
\PYG{l+s+s2}{    telefon TEXT,}
\PYG{l+s+s2}{    email TEXT}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{CREATE TABLE Klienci (}
\PYG{l+s+s2}{    klient\PYGZus{}id INTEGER PRIMARY KEY AUTOINCREMENT,}
\PYG{l+s+s2}{    imie TEXT NOT NULL,}
\PYG{l+s+s2}{    nazwisko TEXT NOT NULL,}
\PYG{l+s+s2}{    email TEXT NOT NULL UNIQUE}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{CREATE TABLE Produkty (}
\PYG{l+s+s2}{    produkt\PYGZus{}id INTEGER PRIMARY KEY AUTOINCREMENT,}
\PYG{l+s+s2}{    nazwa\PYGZus{}produktu TEXT NOT NULL,}
\PYG{l+s+s2}{    cena REAL NOT NULL,}
\PYG{l+s+s2}{    stan\PYGZus{}magazynowy INTEGER NOT NULL,}
\PYG{l+s+s2}{    kategoria\PYGZus{}id INTEGER,}
\PYG{l+s+s2}{    dostawca\PYGZus{}id INTEGER,}
\PYG{l+s+s2}{    FOREIGN KEY (kategoria\PYGZus{}id) REFERENCES Kategorie(kategoria\PYGZus{}id),}
\PYG{l+s+s2}{    FOREIGN KEY (dostawca\PYGZus{}id) REFERENCES Dostawcy(dostawca\PYGZus{}id)}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{CREATE TABLE Zamowienia (}
\PYG{l+s+s2}{    zamowienie\PYGZus{}id INTEGER PRIMARY KEY AUTOINCREMENT,}
\PYG{l+s+s2}{    klient\PYGZus{}id INTEGER NOT NULL,}
\PYG{l+s+s2}{    data\PYGZus{}zamowienia DATETIME NOT NULL,}
\PYG{l+s+s2}{    status TEXT NOT NULL,}
\PYG{l+s+s2}{    FOREIGN KEY (klient\PYGZus{}id) REFERENCES Klienci(klient\PYGZus{}id)}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{CREATE TABLE PozycjeZamowienia (}
\PYG{l+s+s2}{    pozycja\PYGZus{}id INTEGER PRIMARY KEY AUTOINCREMENT,}
\PYG{l+s+s2}{    zamowienie\PYGZus{}id INTEGER NOT NULL,}
\PYG{l+s+s2}{    produkt\PYGZus{}id INTEGER NOT NULL,}
\PYG{l+s+s2}{    ilosc INTEGER NOT NULL,}
\PYG{l+s+s2}{    cena REAL NOT NULL,}
\PYG{l+s+s2}{    FOREIGN KEY (zamowienie\PYGZus{}id) REFERENCES Zamowienia(zamowienie\PYGZus{}id),}
\PYG{l+s+s2}{    FOREIGN KEY (produkt\PYGZus{}id) REFERENCES Produkty(produkt\PYGZus{}id)}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{SCHEMA\PYGZus{}POSTGRES} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{DROP TABLE IF EXISTS PozycjeZamowienia, Zamowienia, Produkty, Klienci, Dostawcy, Kategorie CASCADE;}
\PYG{l+s+s2}{CREATE TABLE Kategorie (}
\PYG{l+s+s2}{    kategoria\PYGZus{}id SERIAL PRIMARY KEY,}
\PYG{l+s+s2}{    nazwa\PYGZus{}kategorii VARCHAR(100) NOT NULL,}
\PYG{l+s+s2}{    opis TEXT}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{CREATE TABLE Dostawcy (}
\PYG{l+s+s2}{    dostawca\PYGZus{}id SERIAL PRIMARY KEY,}
\PYG{l+s+s2}{    nazwa\PYGZus{}firmy VARCHAR(255) NOT NULL,}
\PYG{l+s+s2}{    telefon VARCHAR(20),}
\PYG{l+s+s2}{    email VARCHAR(255)}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{CREATE TABLE Klienci (}
\PYG{l+s+s2}{    klient\PYGZus{}id SERIAL PRIMARY KEY,}
\PYG{l+s+s2}{    imie VARCHAR(100) NOT NULL,}
\PYG{l+s+s2}{    nazwisko VARCHAR(100) NOT NULL,}
\PYG{l+s+s2}{    email VARCHAR(255) NOT NULL UNIQUE}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{CREATE TABLE Produkty (}
\PYG{l+s+s2}{    produkt\PYGZus{}id SERIAL PRIMARY KEY,}
\PYG{l+s+s2}{    nazwa\PYGZus{}produktu VARCHAR(255) NOT NULL,}
\PYG{l+s+s2}{    cena NUMERIC(10, 2) NOT NULL,}
\PYG{l+s+s2}{    stan\PYGZus{}magazynowy INT NOT NULL,}
\PYG{l+s+s2}{    kategoria\PYGZus{}id INT REFERENCES Kategorie(kategoria\PYGZus{}id),}
\PYG{l+s+s2}{    dostawca\PYGZus{}id INT REFERENCES Dostawcy(dostawca\PYGZus{}id)}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{CREATE TABLE Zamowienia (}
\PYG{l+s+s2}{    zamowienie\PYGZus{}id SERIAL PRIMARY KEY,}
\PYG{l+s+s2}{    klient\PYGZus{}id INT NOT NULL REFERENCES Klienci(klient\PYGZus{}id),}
\PYG{l+s+s2}{    data\PYGZus{}zamowienia TIMESTAMP NOT NULL,}
\PYG{l+s+s2}{    status VARCHAR(50) NOT NULL}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{CREATE TABLE PozycjeZamowienia (}
\PYG{l+s+s2}{    pozycja\PYGZus{}id SERIAL PRIMARY KEY,}
\PYG{l+s+s2}{    zamowienie\PYGZus{}id INT REFERENCES Zamowienia(zamowienie\PYGZus{}id),}
\PYG{l+s+s2}{    produkt\PYGZus{}id INT REFERENCES Produkty(produkt\PYGZus{}id),}
\PYG{l+s+s2}{    ilosc INT NOT NULL,}
\PYG{l+s+s2}{    cena DECIMAL(10, 2) NOT NULL}
\PYG{l+s+s2}{);}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{generuj\PYGZus{}dane}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Przygotowuje w pamięci kompletny zestaw danych testowych.}

\PYG{l+s+sd}{    Funkcja tworzy spójny zestaw list z danymi dla klientów, produktów,}
\PYG{l+s+sd}{    zamówień oraz pozycji zamówień. Respektuje przy tym zdefiniowane}
\PYG{l+s+sd}{    relacje i losowo generuje powiązania.}

\PYG{l+s+sd}{    :returns: Słownik zawierający listy krotek dla każdej tabeli.}
\PYG{l+s+sd}{              Klucze: \PYGZsq{}klienci\PYGZsq{}, \PYGZsq{}produkty\PYGZsq{}, \PYGZsq{}zamowienia\PYGZsq{}, \PYGZsq{}pozycje\PYGZus{}zamowien\PYGZsq{}.}
\PYG{l+s+sd}{    :rtype: dict}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{klienci} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{NUM\PYGZus{}KLIENCI}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{imie} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{IMIONA\PYGZus{}M} \PYG{o}{+} \PYG{n}{IMIONA\PYGZus{}K}\PYG{p}{)}
        \PYG{n}{nazwisko} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{NAZWISKA}\PYG{p}{)}
        \PYG{n}{email} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{imie}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{.}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{nazwisko}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{@example.com}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{klienci}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{imie}\PYG{p}{,} \PYG{n}{nazwisko}\PYG{p}{,} \PYG{n}{email}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{produkty} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{NUM\PYGZus{}PRODUKTY}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{nazwa} \PYG{o}{=} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{CZESCI\PYGZus{}PRODUKTU\PYGZus{}1}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{CZESCI\PYGZus{}PRODUKTU\PYGZus{}2}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{cena} \PYG{o}{=} \PYG{n+nb}{round}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{uniform}\PYG{p}{(}\PYG{l+m+mf}{2.5}\PYG{p}{,} \PYG{l+m+mf}{50.0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{n}{stan} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{)}
        \PYG{n}{kat\PYGZus{}id} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{KATEGORIE}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{dos\PYGZus{}id} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{DOSTAWCY}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{produkty}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{nazwa}\PYG{p}{,} \PYG{n}{cena}\PYG{p}{,} \PYG{n}{stan}\PYG{p}{,} \PYG{n}{kat\PYGZus{}id}\PYG{p}{,} \PYG{n}{dos\PYGZus{}id}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{zamowienia} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{statusy} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Złożone}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Wysłane}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dostarczone}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Anulowane}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{NUM\PYGZus{}ZAMOWIENIA}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{klient\PYGZus{}id} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{NUM\PYGZus{}KLIENCI}\PYG{p}{)}
        \PYG{n}{data} \PYG{o}{=} \PYG{n}{datetime}\PYG{o}{.}\PYG{n}{now}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{timedelta}\PYG{p}{(}\PYG{n}{days}\PYG{o}{=}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{365}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{status} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{statusy}\PYG{p}{)}
        \PYG{n}{zamowienia}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{i} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{klient\PYGZus{}id}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{status}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{pozycje\PYGZus{}zamowien} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{pozycja\PYGZus{}id\PYGZus{}counter} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{for} \PYG{n}{zamowienie} \PYG{o+ow}{in} \PYG{n}{zamowienia}\PYG{p}{:}
        \PYG{n}{zamowienie\PYGZus{}id} \PYG{o}{=} \PYG{n}{zamowienie}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{produkt} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{choice}\PYG{p}{(}\PYG{n}{produkty}\PYG{p}{)}
            \PYG{n}{produkt\PYGZus{}id} \PYG{o}{=} \PYG{n}{produkt}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
            \PYG{n}{cena\PYGZus{}w\PYGZus{}chwili\PYGZus{}zakupu} \PYG{o}{=} \PYG{n}{produkt}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
            \PYG{n}{ilosc} \PYG{o}{=} \PYG{n}{random}\PYG{o}{.}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
            \PYG{n}{pozycje\PYGZus{}zamowien}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{pozycja\PYGZus{}id\PYGZus{}counter}\PYG{p}{,} \PYG{n}{zamowienie\PYGZus{}id}\PYG{p}{,} \PYG{n}{produkt\PYGZus{}id}\PYG{p}{,} \PYG{n}{ilosc}\PYG{p}{,} \PYG{n}{cena\PYGZus{}w\PYGZus{}chwili\PYGZus{}zakupu}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{pozycja\PYGZus{}id\PYGZus{}counter} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

    \PYG{k}{return} \PYG{p}{\PYGZob{}}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{klienci}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{klienci}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{produkty}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{produkty}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zamowienia}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{zamowienia}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pozycje\PYGZus{}zamowien}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{pozycje\PYGZus{}zamowien}
    \PYG{p}{\PYGZcb{}}

\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{stworz\PYGZus{}baze\PYGZus{}sqlite}\PYG{p}{(}\PYG{n}{dane}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Tworzy i wypełnia bazę danych SQLite na podstawie dostarczonych danych.}

\PYG{l+s+sd}{    Funkcja usuwa istniejący plik bazy, tworzy nową strukturę}
\PYG{l+s+sd}{    zgodnie ze schematem i wstawia dane za pomocą operacji masowych.}

\PYG{l+s+sd}{    :param dict dane: Słownik z danymi, wynik działania funkcji :func:`generuj\PYGZus{}dane`.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{DB\PYGZus{}NAME\PYGZus{}SQLITE}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{os}\PYG{o}{.}\PYG{n}{remove}\PYG{p}{(}\PYG{n}{DB\PYGZus{}NAME\PYGZus{}SQLITE}\PYG{p}{)}

    \PYG{n}{conn} \PYG{o}{=} \PYG{n}{sqlite3}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{n}{DB\PYGZus{}NAME\PYGZus{}SQLITE}\PYG{p}{)}
    \PYG{n}{cursor} \PYG{o}{=} \PYG{n}{conn}\PYG{o}{.}\PYG{n}{cursor}\PYG{p}{(}\PYG{p}{)}

    \PYG{n}{cursor}\PYG{o}{.}\PYG{n}{executescript}\PYG{p}{(}\PYG{n}{SCHEMA\PYGZus{}SQLITE}\PYG{p}{)}
    \PYG{n}{cursor}\PYG{o}{.}\PYG{n}{executemany}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO Kategorie VALUES (?, ?, ?)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{KATEGORIE}\PYG{p}{)}
    \PYG{n}{cursor}\PYG{o}{.}\PYG{n}{executemany}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO Dostawcy VALUES (?, ?, ?, ?)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{DOSTAWCY}\PYG{p}{)}
    \PYG{n}{cursor}\PYG{o}{.}\PYG{n}{executemany}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO Klienci (klient\PYGZus{}id, imie, nazwisko, email) VALUES (?, ?, ?, ?)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dane}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{klienci}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{cursor}\PYG{o}{.}\PYG{n}{executemany}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO Produkty (produkt\PYGZus{}id, nazwa\PYGZus{}produktu, cena, stan\PYGZus{}magazynowy, kategoria\PYGZus{}id, dostawca\PYGZus{}id) VALUES (?, ?, ?, ?, ?, ?)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dane}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{produkty}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{cursor}\PYG{o}{.}\PYG{n}{executemany}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO Zamowienia (zamowienie\PYGZus{}id, klient\PYGZus{}id, data\PYGZus{}zamowienia, status) VALUES (?, ?, ?, ?)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dane}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zamowienia}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{cursor}\PYG{o}{.}\PYG{n}{executemany}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO PozycjeZamowienia (pozycja\PYGZus{}id, zamowienie\PYGZus{}id, produkt\PYGZus{}id, ilosc, cena) VALUES (?, ?, ?, ?, ?)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{dane}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pozycje\PYGZus{}zamowien}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}

    \PYG{n}{conn}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{conn}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Baza SQLite }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{DB\PYGZus{}NAME\PYGZus{}SQLITE}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ została utworzona pomyślnie.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{stworz\PYGZus{}skrypt\PYGZus{}postgres}\PYG{p}{(}\PYG{n}{dane}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Generuje kompletny plik .sql dla bazy PostgreSQL.}

\PYG{l+s+sd}{    Funkcja tworzy plik .sql, który może być wykonany na serwerze}
\PYG{l+s+sd}{    PostgreSQL w celu odtworzenia identycznej struktury i zawartości}
\PYG{l+s+sd}{    bazy danych. Automatycznie formatuje wartości i aktualizuje sekwencje.}

\PYG{l+s+sd}{    :param dict dane: Słownik z danymi, wynik działania funkcji :func:`generuj\PYGZus{}dane`.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{OUTPUT\PYGZus{}SQL\PYGZus{}POSTGRES}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{encoding}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{utf\PYGZhy{}8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{} Wygenerowany skrypt SQL dla PostgreSQL}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{SCHEMA\PYGZus{}POSTGRES}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{} Wstawianie danych}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{format\PYGZus{}sql}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n+nb}{str}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{val}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}
            \PYG{k}{if} \PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{n}{val}\PYG{p}{,} \PYG{n}{datetime}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{return} \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{val}\PYG{o}{.}\PYG{n}{strftime}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{Y\PYGZhy{}}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{m\PYGZhy{}}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{H:}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{M:}\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}
            \PYG{k}{return} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}

        \PYG{k}{for} \PYG{n}{kat} \PYG{o+ow}{in} \PYG{n}{KATEGORIE}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO Kategorie VALUES (}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{format\PYGZus{}sql}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{kat}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{dos} \PYG{o+ow}{in} \PYG{n}{DOSTAWCY}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO Dostawcy VALUES (}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{format\PYGZus{}sql}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{dos}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{dane}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{klienci}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO Klienci (klient\PYGZus{}id, imie, nazwisko, email) VALUES (}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{format\PYGZus{}sql}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n}{dane}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{produkty}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
             \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO Produkty (produkt\PYGZus{}id, nazwa\PYGZus{}produktu, cena, stan\PYGZus{}magazynowy, kategoria\PYGZus{}id, dostawca\PYGZus{}id) VALUES (}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{format\PYGZus{}sql}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{z} \PYG{o+ow}{in} \PYG{n}{dane}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zamowienia}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO Zamowienia (zamowienie\PYGZus{}id, klient\PYGZus{}id, data\PYGZus{}zamowienia, status) VALUES (}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{format\PYGZus{}sql}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{pz} \PYG{o+ow}{in} \PYG{n}{dane}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pozycje\PYGZus{}zamowien}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{INSERT INTO PozycjeZamowienia (pozycja\PYGZus{}id, zamowienie\PYGZus{}id, produkt\PYGZus{}id, ilosc, cena) VALUES (}\PYG{l+s+si}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{, }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{format\PYGZus{}sql}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{pz}\PYG{p}{)}\PYG{p}{)}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{);}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{} Aktualizacja sekwencji kluczy głównych}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SELECT setval(}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{kategorie\PYGZus{}kategoria\PYGZus{}id\PYGZus{}seq}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{, (SELECT MAX(kategoria\PYGZus{}id) FROM Kategorie));}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SELECT setval(}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{dostawcy\PYGZus{}dostawca\PYGZus{}id\PYGZus{}seq}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{, (SELECT MAX(dostawca\PYGZus{}id) FROM Dostawcy));}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SELECT setval(}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{klienci\PYGZus{}klient\PYGZus{}id\PYGZus{}seq}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{, (SELECT MAX(klient\PYGZus{}id) FROM Klienci));}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SELECT setval(}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{produkty\PYGZus{}produkt\PYGZus{}id\PYGZus{}seq}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{, (SELECT MAX(produkt\PYGZus{}id) FROM Produkty));}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SELECT setval(}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{zamowienia\PYGZus{}zamowienie\PYGZus{}id\PYGZus{}seq}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{, (SELECT MAX(zamowienie\PYGZus{}id) FROM Zamowienia));}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SELECT setval(}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{pozycjezamowienia\PYGZus{}pozycja\PYGZus{}id\PYGZus{}seq}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{, (SELECT MAX(pozycja\PYGZus{}id) FROM PozycjeZamowienia));}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Skrypt dla PostgreSQL }\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{OUTPUT\PYGZus{}SQL\PYGZus{}POSTGRES}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{ został wygenerowany pomyślnie.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Główny blok wykonawczy skryptu.}

\PYG{l+s+sd}{    Jego zadaniem jest orkiestracja całego procesu: wygenerowanie danych,}
\PYG{l+s+sd}{    stworzenie bazy SQLite oraz wygenerowanie skryptu dla PostgreSQL.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Rozpoczynam generowanie baz danych.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{dane\PYGZus{}wygenerowane} \PYG{o}{=} \PYG{n}{generuj\PYGZus{}dane}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{stworz\PYGZus{}baze\PYGZus{}sqlite}\PYG{p}{(}\PYG{n}{dane\PYGZus{}wygenerowane}\PYG{p}{)}
    \PYG{n}{stworz\PYGZus{}skrypt\PYGZus{}postgres}\PYG{p}{(}\PYG{n}{dane\PYGZus{}wygenerowane}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Zakończono. Utworzono plik bazy SQLite i plik .sql dla PostgreSQL.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Analiza i Implementacja Bazy Danych}
\label{\detokenize{rozdzial_4:analiza-i-implementacja-bazy-danych}}\label{\detokenize{rozdzial_4:rozdzial-4}}\label{\detokenize{rozdzial_4::doc}}
\sphinxAtStartPar
Ten rozdział poświęcony jest szczegółowej analizie struktury bazy danych „Sklep”, procesowi jej normalizacji oraz prezentacji kluczowych skryptów i zapytań SQL, które umożliwiają interakcję z danymi.


\section{Analiza Struktury i Normalizacja}
\label{\detokenize{rozdzial_4:analiza-struktury-i-normalizacja}}
\sphinxAtStartPar
Projekt bazy danych został oparty o model relacyjny, co gwarantuje spójność i integralność danych. Proces projektowania uwzględniał zasady normalizacji, aby wyeliminować redundancję i anomalie danych.


\subsection{Pierwsza Postać Normalna (1NF)}
\label{\detokenize{rozdzial_4:pierwsza-postac-normalna-1nf}}
\sphinxAtStartPar
Każda tabela w bazie posiada klucz główny, a wszystkie atrybuty w tabelach przechowują wartości atomowe (niepodzielne). Przykładowo, w tabeli \sphinxtitleref{Klienci} adres email jest pojedynczą informacją, a w \sphinxtitleref{Produktach} cena jest jedną liczbą. Nie ma pól, które zawierałyby listy czy zbiory danych.


\subsection{Druga Postać Normalna (2NF)}
\label{\detokenize{rozdzial_4:druga-postac-normalna-2nf}}
\sphinxAtStartPar
Wszystkie atrybuty w tabelach, które mają klucze złożone (w naszym przypadku tylko tabela asocjacyjna \sphinxtitleref{PozycjeZamowienia}), są w pełni zależne od całego klucza głównego. W pozostałych tabelach klucze główne są proste (jednopolowe), więc warunek 2NF jest automatycznie spełniony. W \sphinxtitleref{PozycjeZamowienia} atrybuty \sphinxtitleref{ilosc} i \sphinxtitleref{cena} zależą zarówno od \sphinxtitleref{zamowienie\_id}, jak i \sphinxtitleref{produkt\_id}.


\subsection{Trzecia Postać Normalna (3NF)}
\label{\detokenize{rozdzial_4:trzecia-postac-normalna-3nf}}
\sphinxAtStartPar
W bazie nie występują zależności przechodnie. Żaden atrybut niekluczowy nie jest zależny od innego atrybutu niekluczowego. Na przykład, w tabeli \sphinxtitleref{Produkty} nie przechowujemy nazwy kategorii czy danych dostawcy – zamiast tego używamy kluczy obcych (\sphinxtitleref{kategoria\_id}, \sphinxtitleref{dostawca\_id}), które wskazują na odpowiednie rekordy w tabelach \sphinxtitleref{Kategorie} i \sphinxtitleref{Dostawcy}. Dzięki temu zmiana nazwy kategorii wymaga modyfikacji tylko jednego rekordu w tabeli \sphinxtitleref{Kategorie}.

\sphinxAtStartPar
Podsumowując, schemat bazy danych jest zgodny z \sphinxstylestrong{trzecią postacią normalną (3NF)}, co jest standardem dla dobrze zaprojektowanych relacyjnych baz danych.


\section{Skrypty SQL i Generowanie Danych}
\label{\detokenize{rozdzial_4:skrypty-sql-i-generowanie-danych}}
\sphinxAtStartPar
Do stworzenia i wypełnienia bazy danych przygotowano skrypty SQL dla dwóch popularnych systemów: SQLite oraz PostgreSQL.


\subsection{Implementacja w SQLite}
\label{\detokenize{rozdzial_4:implementacja-w-sqlite}}
\sphinxAtStartPar
Poniższy fragment kodu SQL definiuje kompletną strukturę tabel dla bazy SQLite. Używa typów danych specyficznych dla tego systemu, takich jak \sphinxtitleref{INTEGER PRIMARY KEY} dla automatycznie inkrementowanych kluczy.
\sphinxSetupCaptionForVerbatim{Schemat bazy danych dla SQLite}
\def\sphinxLiteralBlockLabel{\label{\detokenize{rozdzial_4:id1}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Kategorie}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{kategoria\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INTEGER}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{nazwa\PYGZus{}kategorii}\PYG{+w}{ }\PYG{n+nb}{TEXT}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{opis}\PYG{+w}{ }\PYG{n+nb}{TEXT}
\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Produkty}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{produkt\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INTEGER}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{+w}{ }\PYG{n}{AUTOINCREMENT}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{nazwa\PYGZus{}produktu}\PYG{+w}{ }\PYG{n+nb}{TEXT}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{cena}\PYG{+w}{ }\PYG{n+nb}{REAL}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{stan\PYGZus{}magazynowy}\PYG{+w}{ }\PYG{n+nb}{INTEGER}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{kategoria\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INTEGER}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{dostawca\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INTEGER}\PYG{p}{,}
\PYG{+w}{    }\PYG{k}{FOREIGN}\PYG{+w}{ }\PYG{k}{KEY}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{kategoria\PYGZus{}id}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Kategorie}\PYG{p}{(}\PYG{n}{kategoria\PYGZus{}id}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{k}{FOREIGN}\PYG{+w}{ }\PYG{k}{KEY}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{dostawca\PYGZus{}id}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Dostawcy}\PYG{p}{(}\PYG{n}{dostawca\PYGZus{}id}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} ... pozostałe tabele ...}
\end{sphinxVerbatim}


\subsection{Implementacja w PostgreSQL}
\label{\detokenize{rozdzial_4:implementacja-w-postgresql}}
\sphinxAtStartPar
Dla systemu PostgreSQL schemat wykorzystuje bardziej rygorystyczne typy danych (\sphinxtitleref{VARCHAR}, \sphinxtitleref{NUMERIC}, \sphinxtitleref{TIMESTAMP}) oraz sekwencje (\sphinxtitleref{SERIAL}) do automatycznego generowania kluczy głównych.
\sphinxSetupCaptionForVerbatim{Schemat bazy danych dla PostgreSQL}
\def\sphinxLiteralBlockLabel{\label{\detokenize{rozdzial_4:id2}}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Kategorie}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{kategoria\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{nazwa\PYGZus{}kategorii}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{opis}\PYG{+w}{ }\PYG{n+nb}{TEXT}
\PYG{p}{)}\PYG{p}{;}
\PYG{k}{CREATE}\PYG{+w}{ }\PYG{k}{TABLE}\PYG{+w}{ }\PYG{n}{Produkty}\PYG{+w}{ }\PYG{p}{(}
\PYG{+w}{    }\PYG{n}{produkt\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{SERIAL}\PYG{+w}{ }\PYG{k}{PRIMARY}\PYG{+w}{ }\PYG{k}{KEY}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{nazwa\PYGZus{}produktu}\PYG{+w}{ }\PYG{n+nb}{VARCHAR}\PYG{p}{(}\PYG{l+m+mi}{255}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{cena}\PYG{+w}{ }\PYG{n+nb}{NUMERIC}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{stan\PYGZus{}magazynowy}\PYG{+w}{ }\PYG{n+nb}{INT}\PYG{+w}{ }\PYG{k}{NOT}\PYG{+w}{ }\PYG{k}{NULL}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{kategoria\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INT}\PYG{+w}{ }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Kategorie}\PYG{p}{(}\PYG{n}{kategoria\PYGZus{}id}\PYG{p}{)}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{dostawca\PYGZus{}id}\PYG{+w}{ }\PYG{n+nb}{INT}\PYG{+w}{ }\PYG{k}{REFERENCES}\PYG{+w}{ }\PYG{n}{Dostawcy}\PYG{p}{(}\PYG{n}{dostawca\PYGZus{}id}\PYG{p}{)}
\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{\PYGZhy{}\PYGZhy{} ... pozostałe tabele ...}
\end{sphinxVerbatim}


\section{Przykładowe Zapytania i Optymalizacja}
\label{\detokenize{rozdzial_4:przykladowe-zapytania-i-optymalizacja}}
\sphinxAtStartPar
Poniżej znajdują się przykłady zapytań SQL, które można wykonać na bazie „Sklep”, wraz z omówieniem potencjalnych optymalizacji.


\subsection{Zapytanie 1: Suma wartości zamówień dla każdego klienta}
\label{\detokenize{rozdzial_4:zapytanie-1-suma-wartosci-zamowien-dla-kazdego-klienta}}
\sphinxAtStartPar
To zapytanie oblicza łączną kwotę wydaną przez każdego klienta.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}
\PYG{+w}{    }\PYG{n}{k}\PYG{p}{.}\PYG{n}{imie}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{k}\PYG{p}{.}\PYG{n}{nazwisko}\PYG{p}{,}
\PYG{+w}{    }\PYG{n}{k}\PYG{p}{.}\PYG{n}{email}\PYG{p}{,}
\PYG{+w}{    }\PYG{k}{SUM}\PYG{p}{(}\PYG{n}{pz}\PYG{p}{.}\PYG{n}{ilosc}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{pz}\PYG{p}{.}\PYG{n}{cena}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{n}{laczna\PYGZus{}wartosc\PYGZus{}zamowien}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{Klienci}\PYG{+w}{ }\PYG{n}{k}
\PYG{k}{JOIN}\PYG{+w}{ }\PYG{n}{Zamowienia}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{.}\PYG{n}{klient\PYGZus{}id}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{z}\PYG{p}{.}\PYG{n}{klient\PYGZus{}id}
\PYG{k}{JOIN}\PYG{+w}{ }\PYG{n}{PozycjeZamowienia}\PYG{+w}{ }\PYG{n}{pz}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{z}\PYG{p}{.}\PYG{n}{zamowienie\PYGZus{}id}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pz}\PYG{p}{.}\PYG{n}{zamowienie\PYGZus{}id}
\PYG{k}{GROUP}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{.}\PYG{n}{klient\PYGZus{}id}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{.}\PYG{n}{imie}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{.}\PYG{n}{nazwisko}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{.}\PYG{n}{email}
\PYG{k}{ORDER}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{laczna\PYGZus{}wartosc\PYGZus{}zamowien}\PYG{+w}{ }\PYG{k}{DESC}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Optymalizacja:} Zapytanie wykorzystuje złączenia (JOIN) tabel. Aby przyspieszyć jego wykonanie, kluczowe jest posiadanie \sphinxstylestrong{indeksów} na kolumnach używanych do złączeń, czyli \sphinxtitleref{Klienci(klient\_id)}, \sphinxtitleref{Zamowienia(klient\_id)}, \sphinxtitleref{Zamowienia(zamowienie\_id)} oraz \sphinxtitleref{PozycjeZamowienia(zamowienie\_id)}. W naszym schemacie kolumny te są kluczami głównymi lub obcymi, na których systemy bazodanowe zazwyczaj automatycznie tworzą indeksy.


\subsection{Zapytanie 2: Znalezienie 5 najpopularniejszych produktów}
\label{\detokenize{rozdzial_4:zapytanie-2-znalezienie-5-najpopularniejszych-produktow}}
\sphinxAtStartPar
To zapytanie zlicza, ile razy każdy produkt został zamówiony.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{SELECT}
\PYG{+w}{    }\PYG{n}{p}\PYG{p}{.}\PYG{n}{nazwa\PYGZus{}produktu}\PYG{p}{,}
\PYG{+w}{    }\PYG{k}{COUNT}\PYG{p}{(}\PYG{n}{pz}\PYG{p}{.}\PYG{n}{produkt\PYGZus{}id}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{AS}\PYG{+w}{ }\PYG{n}{liczba\PYGZus{}zamowien}
\PYG{k}{FROM}\PYG{+w}{ }\PYG{n}{Produkty}\PYG{+w}{ }\PYG{n}{p}
\PYG{k}{JOIN}\PYG{+w}{ }\PYG{n}{PozycjeZamowienia}\PYG{+w}{ }\PYG{n}{pz}\PYG{+w}{ }\PYG{k}{ON}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{produkt\PYGZus{}id}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pz}\PYG{p}{.}\PYG{n}{produkt\PYGZus{}id}
\PYG{k}{GROUP}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{produkt\PYGZus{}id}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{p}\PYG{p}{.}\PYG{n}{nazwa\PYGZus{}produktu}
\PYG{k}{ORDER}\PYG{+w}{ }\PYG{k}{BY}\PYG{+w}{ }\PYG{n}{liczba\PYGZus{}zamowien}\PYG{+w}{ }\PYG{k}{DESC}
\PYG{k}{LIMIT}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Optymalizacja:} Podobnie jak w poprzednim przypadku, wydajność zależy od indeksów na kolumnach \sphinxtitleref{Produkty(produkt\_id)} i \sphinxtitleref{PozycjeZamowienia(produkt\_id)}. Przy bardzo dużej liczbie pozycji w zamówieniach, wydajność można by dalej poprawić poprzez denormalizację, np. dodając licznik zamówień bezpośrednio w tabeli \sphinxtitleref{Produkty}, jednak odbyłoby się to kosztem utrzymania spójności danych. Dla obecnej struktury indeksy są wystarczające.

\sphinxstepscope


\chapter{Struktura Repozytoriów Projektowych}
\label{\detokenize{rozdzial_5:struktura-repozytoriow-projektowych}}\label{\detokenize{rozdzial_5:rozdzial-5}}\label{\detokenize{rozdzial_5::doc}}

\section{Projekt został zrealizowany w oparciu o rozproszony system kontroli wersji Git, a platforma GitHub posłużyła jako centralne miejsce do przechowywania kodu, koordynacji prac oraz integracji poszczególnych części sprawozdania. Poniżej przedstawiono kompletną listę repozytoriów wykorzystanych w projekcie.}
\label{\detokenize{rozdzial_5:projekt-zostal-zrealizowany-w-oparciu-o-rozproszony-system-kontroli-wersji-git-a-platforma-github-posluzyla-jako-centralne-miejsce-do-przechowywania-kodu-koordynacji-prac-oraz-integracji-poszczegolnych-czesci-sprawozdania-ponizej-przedstawiono-kompletna-liste-repozytoriow-wykorzystanych-w-projekcie}}

\section{Repozytoria z Opracowaniami Tematycznymi}
\label{\detokenize{rozdzial_5:repozytoria-z-opracowaniami-tematycznymi}}
\sphinxAtStartPar
Każdy z tematów teoretycznych został opracowany w osobnym repozytorium, co pozwoliło na równoległą pracę członków zespołu.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Temat:} Sprzęt dla bazy danych
*
*   \sphinxstylestrong{Link:} \sphinxhref{https://github.com/oszczeda/Sprzet-dla-bazy-danych}{oszczeda/Sprzet\sphinxhyphen{}dla\sphinxhyphen{}bazy\sphinxhyphen{}danych}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Temat:} Konfiguracja bazy danych
*
*   \sphinxstylestrong{Link:} \sphinxhref{https://github.com/Chaiolites/Konfiguracja\_baz\_danych}{Chaiolites/Konfiguracja\_baz\_danych}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Temat:} Kontrola i konserwacja
*
*   \sphinxstylestrong{Link:} \sphinxhref{https://github.com/Pi0trM/Kontrola\_i\_konserwacja}{Pi0trM/Kontrola\_i\_konserwacja}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Temat:} Monitorowanie i diagnostyka
*
*   \sphinxstylestrong{Link:} \sphinxhref{https://github.com/GrzegorzSzczepanek/repo-wspolne}{GrzegorzSzczepanek/repo\sphinxhyphen{}wspolne}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Temat:} Wydajność, skalowanie i replikacja
*
*   \sphinxstylestrong{Link:} \sphinxhref{https://github.com/Broksonn/Wydajnosc\_Skalowanie\_i\_Replikacja}{Broksonn/Wydajnosc\_Skalowanie\_i\_Replikacja}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Temat:} Partycjonowanie danych
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Link:} \sphinxhref{https://github.com/BartekHen/Partycjonowanie-danych}{BartekHen/Partycjonowanie\sphinxhyphen{}danych}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Temat:} Bezpieczeństwo
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Link:} \sphinxhref{https://github.com/BlazejUl/bezpieczenstwo}{BlazejUl/bezpieczenstwo}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Temat:} Kopie zapasowe i odzyskiwanie danych
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Link:} \sphinxhref{https://github.com/m-smieja/Kopie\_zapasowe\_i\_odzyskiwanie\_danych}{m\sphinxhyphen{}smieja/Kopie\_zapasowe\_i\_odzyskiwanie\_danych}

\end{itemize}

\end{enumerate}



\renewcommand{\indexname}{Indeks}
\printindex
\end{document}